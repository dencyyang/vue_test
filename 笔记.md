# vue_test

## Project setup
```
npm install
```

## Compiles and hot-reloads for development
```
npm run serve
```

## Compiles and minifies for production
```
npm run build //打包文件 dist文件夹
```

## Lints and fixes files
```
npm run lint
```
## Customize configuration
# JS
## JS基础
### 变量提升
    会将当前作用域的所有变量的声明，提升到程序的顶部在编译阶段阶段，代码真正执行前的几毫秒，会检测到所有的变量和函数声明，所有这些函数和变量声明都被添加到名为Lexical Environment的JavaScript数据结构内的内存中。所以这些变量和函数能在它们真正被声明之前使用。
    当函数声明与其他声明一起出现的时候以函数声明为准，有多个函数声明的时候，是由最后的函数声明来替代前面的
    var a = 2这种语句，会拆分开，将var a这步进行提升。
### 作用域
    作用域就是一个变量或者函数的有效作用范围，在JS中作用域一共有四种，分别是全局作用域(Global)、局部作用域(Local)、块作用域(Block)、脚本作用域(Script)
    变量声明的三种方式var、let、const
    
    脚本作用域 Script
    脚本作用域是针对于 let 和const声明的变量
    在函数外部用 let 或者 const 声明的变量，的作用范围为script，也就是当前脚本内有效，跟var的全局变量差不多
    局部作用域 Local
    在函数中用 var 、let 、const 声明的所有变量，都是函数的局部变量，作用范围为局部作用域，即：只能在函数内部使用，函数外部使用是不行的
    
    块级作用域 Block
    ECMAScript 6(简称ES 6)中新增了块级作用域
    在 ES 6 之前，是没有块级作用域的概念的。
    ES 6 可以使用 let 关键字或者 const 关键字来实现块级作用域。
    let 或 const声明的变量只在 let 或 const命令所在的代码块 {} 内有效，在 {} 之外不能访问。
### 对象
    对象添加属性：对象.属性名=属性值 /对象['属性名']=属性值 
    读取对象属性：对象.属性名  /对象[属性名](在[]中可以直接传递一个变量，这样变量的值是多少就会读取哪个属性,for in 遍历对象可用此)
     //object.keys()方法遍历对象,将对象key值以数组形式返回
    //for( key in obj){} 遍历数组/对象
### 数组
#### 数组的方法
1. push()
			  - 用来向数组的末尾添加一个或多个元素，并返回数组新的长度
			  - 语法：数组.push(元素1,元素2,元素N)
2. pop()
			  - 用来删除数组的最后一个元素，并返回被删除的元素
3. unshift()
			  - 向数组的前边添加一个或多个元素，并返回数组的新的长度
4. shift()
			  - 删除数组的前边的一个元素，并返回被删除的元素
5. slice()
			  - 可以从一个数组中截取指定的元素
			  - 该方法不会影响原数组，而是将截取到的内容封装为一个新的数组并返回
			  语法：
			  数组.slice（开始索引，结束索引）
			  - 参数：
				  1.截取开始位置的索引（包括开始位置）
				  2.截取结束位置的索引（不包括结束位置）
					- 第二个参数可以省略不写，如果不写则一直截取到最后
				  - 参数可以传递一个负值，如果是负值，则从后往前数
6. splice()
			  - 可以用来删除数组中指定元素，并使用新的元素替换
				该方法会将删除的元素封装到新数组中返回
			  - 参数：
				1.删除开始位置的索引
				2.删除的个数
				3.三个以后，都是替换的元素，这些元素将会插入到开始位置索引的前边
7. sort() 方法以字母顺序对数组进行排序：
8. arr.sort(function(a, b){return a - b});升序排序，b-a降序排序 
9. reverse() 方法反转数组中的元素。
10. split()
		        - 可以根据指定内容将一个字符串拆分为一个数组
		        - 参数：
		         - 需要一个字符串作为参数，将会根据字符串去拆分数组
			        -可以接收一个正则表达式，此时会根据正则表达式去拆分数组
11. reverse()
		- 可以用来反转一个数组，它会对原数组产生影响
12. concat()
	    	- 可以连接两个或多个数组，它不会影响原数组，而是新数组作为返回值返回
	    	语法：arr.concat（arr1,arr2，'as','nun'）;
13. join()
	    	- 可以将一个数组转换为一个字符串
	    	语法：arr.join（"链接字符串"）
	    	- 参数：
	    		需要一个字符串作为参数，这个字符串将会作为连接符来连接数组中的元素
	    		如果不指定连接符则默认使用,
14. sort()
	    	- 可以对一个数组中的内容进行排序，默认是按照Unicode编码进行排序
	    		调用以后，会直接修改原数组。
	    	- 可以自己指定排序的规则，需要一个回调函数作为参数：
	    		function(a,b){
          
	    			//升序排列
	    			//return a-b;
    
	    			//降序排列
	    			return b-a;
	    		}
15. filter()
	    		filter也是一个常用的操作，它用于把Array的某些元素过滤掉，然后返回剩下
	    		的元素。和map()类似，Array的filter()也接收一个函数。和map()不同的是
	    		filter()把传入的函数依次作用于每个元素，然后根据返回值是true还是false
	    		决定保留还是丢弃该元素。
16. indexOf()方法可返回某个指定的字符串值在字符串中首次出现的位置。	
	    		若字符串值在字符串中不包含，则返回-1
	    		stringObject.indexOf(searchvalue,fromindex)
	    		searchvalue	必需。规定需检索的字符串值。
          fromindex	可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 
          stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。
#### 遍历数组
		- 遍历数组就是将数组中元素都获取到
		- 一般情况我们都是使用for循环来遍历数组：
			for(var i=0 ; i<数组.length ; i++){
				//数组[i]
			}
			
		- 使用forEach()方法来遍历数组（不兼容IE8）
		
			语法：数组.forEach(function(value , index , obj){
			
			});
			
			forEach()方法需要一个回调函数(指的是由我们创建不由我们调用的函数)作为参数，
				数组中有几个元素，回调函数就会被调用几次，
				每次调用时，都会将遍历到的信息以实参的形式传递进来，
				我们可以定义形参来获取这些信息。
				value:正在遍历的元素
				index:正在遍历元素的索引
				obj:被遍历对象
			
		-    //object.keys()方法遍历对象,将对象key值以数组形式返回
	    //for( key in obj){} 遍历数组/对象
		*/	
		arr5.forEach(function(a,index,obj){
			console.log('a='+a)
			console.log('a='+index)
			console.log('a='+obj)
	
		});
		console.log(arr.slice(1,4));
		console.log(arr.slice(-3,-1));
		arr.splice(0,2,'ahs','ad');
		console.log(arr);
		数组方法
### 自定义属性
    ata-属性名='属性值' 
    element.dataset.属性名='属性值'
    element.dataset['属性'];
### 获取元素|节点以及元素属性的方法
  节点不一定是元素，但元素一定会是节点
1.  获取节点
    节点.nodeType  获取节点类型
    节点.parentNode  获取节点的父节点(元素的最近节点)
    节点.childNodes  获取所有的子节点(元素节点、文本节点、换行节点间)
    节点.children    获取所有的子元素节点(返回值为数组的形式)
    节点.firstChild  获取第一个子节点(元素和文本都算)
    节点.firstElementChild  获取第一个元素子节点
    节点.lastElementChild  获取最后一个元素子节点
2. 获取元素
    document.getElementById('id')
    document.getEmementsByTagName('标签名')  以为数组的形式保存
    document.getelementsByClassName('类名')
    document.querySlector('选择器')  返回指定选择器的第一个元素
    document.querySlectorAll('选择器')  返回指定选择器的所有元素
    document.body  获取body 返回的是一个对象
    doucment.documentElement  获取html对象
    


3. 获取元素属性
    element.属性名  获取自带属性
    element.getAttribute('属性名')  获取自定义属性
    element.setAttribute('属性名','属性值')  修改自定义属性值
    element.removeAttribute('属性名')  移出自定义属性值
    
    data-属性名='属性值' 自定义属性

### 元素位置计算
1. 
offsetParent就是自己祖先元素中，离自己最近的已经定位的元素，若自己的祖先元素中，没有任何盒子进行了定位，
那么offsetParent****对象就是body****
ele.offsetLeft 一个元素的offsetLeft值，就是这个元素左边框外，到自己的offsetParent对象的左边框内的距离。

ele.offsetTop 一个元素的offsetTop值，就是这个元素上边框外，到自己的offsetParent对象的上边框内的距离。

ele.offsetWidth 一个元素的offsetWidth值，就是这个元素的width+左右pannding+左右border。

ele.offsetHeight 一个元素的offsetWidth值，就是这个元素的height+左右pannding+左右border。

ele.clientWidth 一个元素的offsetWidth值，就是这个元素的width+左右pannding+左右border

ele.clientHeigh 一个元素的offsetWidth值，就是这个元素的height+左右pannding。
### 操作元素修改属性样式
1.  element.innerText 修改起始位置到终止位置的内容包括空格和换行，但不包括html标签
    element.innerHtml 修改起始位置到终止位置的内容包括html标签，但不包括空格和换行
    element.src       修改路径
    element.ref       修改链接
    element.title     修改title
2.  修改表单元素属性
    表单元素 (1) input 表单输入元素 (2)select 元素定义下拉列表 (3)option 选择元素 与select配合形成下拉选择框
    input.value       获取input框内容
    input.checked     获取input框内容
    input.type        修改表单类型
3. 修改按钮属性
    button.disable    布尔值，true表示按钮禁用，false 可用
4.修改样式属性
  element.style.属性名(属性名采用驼峰命名法)   修改行内样式
  element.className 修改类名                 当修改style属性较多时可以通过修改类名实现 

### 事件
#### 注册事件
    addEventListener(type,listener,useCapture)
    type:事件类型字符串，比如click,mouseover
    listener:事件处理函数，事件发生时则会调用该函数
    useCapture:可选参数，布尔值，默认为false(事件捕捉模式)
#### 鼠标事件
    mousedown 鼠标按下  mouseup 鼠标释放  click 左键单击  dblclick 左键双击
    mousemove 鼠标移动  mouseover 鼠标经过  mouseout 鼠标滑出 mouseenter 鼠标进入
    mouseleave 鼠标离开 contextmenu 右键菜单
    e.clientX|Y 返回鼠标相对于浏览器窗口可视区域的X|Y的坐标
    e.pageX|Y   返回鼠标相对于文档页面的X|Y坐标(即有滚动条时距离的原点是文档左上角)
    e.screenX|Y 返回鼠标相对于屏幕的的X|Y坐标
    e.offSetX|Y 属性返回鼠标指针相对于目标元素的X|Y 坐标(目标元素即触发事件的元素e.target)。
    //注册监听事件
    document.addEventListener('click',function(){
      conlog.log(e.clientX)
      conlog.log(e.clientY)
    })
    movement
### change事件
  change 事件被<input>, <select>, 和<textarea> 元素触发
  //触发情况
      1.<input type="radio"> 和 <input type="checkbox"> 的默认选项被修改时（通过点击或者键盘事件）。
      2.当用户完成提交动作时 (例如：点击了 <select>中的一个选项，从 <input type="date">标签选择了一个日期，
      通过 <input type="file">标签上传了一个文件等 )。
      3.当标签的值被修改并且失去焦点后，但并未进行提交 
      (例如：对<textarea> 或者<input type="text">的值进行编辑后)。
### 模板字符串
    模板字面量是允许嵌入表达式的字符串字面量(即字符串中有表达式或者变量)
    `${a+b}的值不是15` 读变量${}
### 数据类型的分类和判断
* 基本(值)类型
  * Number ----- 任意数值 -------- typeof
  * String ----- 任意字符串 ------ typeof
  * Boolean ---- true/false ----- typeof
  * undefined --- undefined ----- typeof/===
  * null -------- null ---------- ===
* 对象(引用)类型
  * Object ----- typeof/instanceof
  * Array ------ instanceof
  * Function ---- typeof

### 数据,变量, 内存的理解
* 什么是数据?
  * 在内存中可读的, 可传递的保存了特定信息的'东东'
  * 一切皆数据, 函数也是数据
  * 在内存中的所有操作的目标: 数据
* 什么是变量?
  * 在程序运行过程中它的值是允许改变的量
  * 一个变量对应一块小内存, 它的值保存在此内存中  
* 什么是内存?
  * 内存条==>集成电路==>通电==>暂时存储正在运行的程序及其产生的数据==>程序停止==>占用的空间自动释放
  * 一块内存包含2个方面的数据
    * 内部存储的数据
    * 地址值数据
  * 内存空间的分类
    * 栈空间: 全局变量/函数, 局部变量/函数
    * 堆空间: 对象  
* 内存,数据, 变量三者之间的关系
  * 内存是容器, 用来存储不同数据
  * 变量是内存的标识, 通过变量我们可以操作(读/写)内存中的数据  
* a = xxx, a中保存的到底做了什么?
  * xxx是一个基本数据: a中保存的就是xxx基本数据
  * xxx是一个对象: a中保存的就是对象内存的地址值
  * xxx是一个变量: a保存的就是变量的值(基本值/地址值)
  
### 对象的理解和使用
* 什么是对象?
  * 多个数据(属性)的集合
  * 用来保存多个数据(属性)的容器
* 属性组成:
  * 属性名 : 字符串(标识)
  * 属性值 : 任意类型
* 属性的分类:
  * 一般 : 属性值不是function  描述对象的状态
  * 方法 : 属性值为function的属性  描述对象的行为
* 特别的对象
  * 数组: 属性名是0,1,2,3之类的索引
  * 函数: 可以执行的
* 如何操作内部属性(方法)
  * .属性名
  * ['属性名']: 属性名有特殊字符/属性名是一个变量
  
### 函数的理解和使用
* 什么是函数?
  * 用来实现特定功能的, n条语句的封装体
  * 只有函数类型的数据是可以执行的, 其它的都不可以
* 为什么要设计函数语法?
* 使用函数有什么好处?
  * 提高复用性
  * 便于阅读交流
* 函数也是对象
  * instanceof Object===true
  * 函数有属性: prototype
  * 函数有方法: call()/apply()
  * 可以添加新的属性/方法
* 函数的3种不同角色
  * 一般函数 : 直接调用
  * 构造函数 : 通过new调用
  * 对象 : 通过.调用内部的属性/方法
* 函数中的this
  * 显式指定谁: obj.xxx()
  * 通过call/apply指定谁调用: xxx.call(obj)
  * 不指定谁调用: xxx()  : window
  * 回调函数: 看背后是通过谁来调用的: window/其它
* 匿名函数自调用:
  ```
  (function(w, obj){
    //实现代码
  })(window, obj)
  ```
  * 专业术语为: IIFE (Immediately Invoked Function Expression) 立即调用函数表达式
						  
### 回调函数的理解
* 什么函数才是回调函数?
  * 你定义的
  * 你没有调用
  * 但它最终执行了(在一定条件下或某个时刻)
* 常用的回调函数
  * dom事件回调函数
  * 定时器回调函数
  * ajax请求回调函数
  * 生命周期回调函数(后面讲解)
## 对象高级
### 对象的创建模式
* Object构造函数模式
  ```
  var obj = {};
  //中间有别的代码
  obj.name = 'Tom'
  obj.setName = function(name){this.name=name}
  ```
* 对象字面量模式
  ```
  var obj = {
    name : 'Tom',
    setName : function(name){this.name = name}
  }
  ```
* 构造函数模式
  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
    this.setName = function(name){this.name=name;};
  }
  new Person('tom', 12);
  ```
* 构造函数+原型的组合模式
  ```
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  Person.prototype.setName = function(name){this.name=name;};
  new Person('tom', 12);
  ```

### 继承模式
* 原型链继承 : 得到方法
  ```
  function Parent(){}
  Parent.prototype.test = function(){};
  function Child(){}
  Child.prototype = new Parent();
  var child = new Child(); //有test()
  ```
* 借用构造函数 : 得到属性
  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
  }
  var child = new Child('a', 'b');  //child.xxx为'a', 但child没有test()
  ```
* 组合
  ```
  function Parent(xxx){this.xxx = xxx}
  Parent.prototype.test = function(){};
  function Child(xxx,yyy){
      Parent.call(this, xxx);//借用构造函数   this.Parent(xxx)
      this.yyy = yyy
  }
  Child.prototype = new Parent(); //得到test()
  var child = new Child(); //child.xxx为'a', 也有test()
  ```
* new一个对象背后做了些什么?
  * 创建一个空对象
  * 给对象设置__proto__, 值为构造函数对象的prototype属性值
  * 执行构造函数体(给对象添加属性/方法)
## 函数高级
### 原型与原型链
* 所有函数都有一个特别的属性:
  * `prototype` : 显式原型属性
* 所有实例对象都有一个特别的属性:
  * `__proto__` : 隐式原型属性
* 显式原型与隐式原型的关系
  * 函数的prototype: 定义函数时被自动赋值, 值默认为{}, 即用为原型对象
  * 实例对象的__proto__: 在创建实例对象时被自动添加, 并赋值为构造函数的prototype值
  * 原型对象即为当前实例对象的父对象
* 原型链
  * 所有的实例对象都有__proto__属性, 它指向的就是原型对象
  * 这样通过__proto__属性就形成了一个链的结构---->原型链
  * 当查找对象内部的属性/方法时, js引擎自动沿着这个原型链查找
  * 当给对象属性赋值时不会使用原型链, 而只是在当前对象中进行操作
### 上下文环境对象与上下文环境栈
* 变量提升与函数提升
  * 变量提升: 在变量定义语句之前, 就可以访问到这个变量(undefined)
  * 函数提升: 在函数定义语句之前, 就执行该函数
  * 简单原因: js引擎在准备执行全局代码和函数体之前, 都会做'预处理'(收集变量/函数)
* 理解
  * 环境对象: 由js引擎自动创建的对象, 包含对应作用域中的变量属性
  * 环境对象栈: 用来管理产生的多个环境对象
* 分类:
  * 全局: window
  * 函数: 对程序员来说是透明的
* 生命周期
  * 全局 : 准备执行全局代码前产生, 当页面刷新/关闭页面时死亡
  * 函数 : 调用函数时产生, 函数执行完时死亡
* 包含哪些属性:
  * 全局 : 
    * 用var定义的全局变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===>window
  * 函数
    * 用var定义的局部变量  ==>undefined
    * 使用function声明的函数   ===>function
    * this   ===> 调用函数的对象, 如果没有指定就是window 
    * 形参变量   ===>对应实参值
    * arguments ===>实参列表的伪数组
* 上下文对象创建和初始化的过程
  * 全局:
    * 在全局代码执行前最先创建一个全局上下文对象(window)
    * 收集一些全局变量, 并初始化
    * 将这些变量设置为上下文对象的属性
  * 函数:
    * 在调用函数时, 在执行函数体之前先创建一个函数上下文对象
    * 收集一些局部变量, 并初始化
    * 将这些变量设置为上下文对象的属性
### 作用域与作用域链
* 理解:
  * 作用域: 一块代码区域, 在编码时就确定了, 不会再变化
  * 作用域链: 多个嵌套的作用域形成的由内向外的结构, 用于查找变量
* 分类:
  * 全局
  * 函数
  * js没有块作用域(在ES6之前)
* 作用?
  * 作用域: 隔离变量, 可以在不同作用域定义同名的变量不冲突
  * 作用域链: 查找变量
* 区别作用域与上下文环境
  * 作用域: 静态的, 编码时就确定了(不是在运行时), 一旦确定就不会变化了
  * 上下文环境: 动态的, 执行代码时动态创建(对象), 当执行结束消失
  * 联系: 上下文环境是在对应的作用域中的

### 闭包 
* 理解:
  * 当嵌套的内部函数引用了外部函数的变量时就产生了闭包
  * 通过chrome工具得知: 闭包本质是内部函数中的一个对象, 这个对象中包含引用的变量属性
* 作用:
  * 延长局部变量的生命周期
  * 让函数外部能操作内部的局部变量
* 写一个闭包程序
  ```
  function fn1() {
    var a = 2;
    function fn2() {
      a++;
      console.log(a);
    }
    return fn2;
  }
  var f = fn1();
  f();
  f();
  ```
* 闭包应用:
  * 回调函数
  * 模块化编码: 封装一些数据以及操作数据的函数, 向外暴露一些行为
  * 循环遍历加监听
  * jQuery大量使用的闭包
* 缺点:
  * 变量占用内存的时间可能会过长
  * 可能导致内存泄露
  * 解决:
    * 及时释放 : f = null; //让内部函数对象成为垃圾对象

### 内存泄露与内存溢出
* 内存泄露
  * 定义: 不再需要的内存对象, 因为某种原因不能成为垃圾对象而一直不能被回收(占用内存)
  * 例如: 意外的全局变量, 定时器, 闭包...
  * 问题: 导致可用内存减小
  * 解决: 及时释放内存
* 内存溢出
  * 定义: 申请/需要的空间超过了剩余的最大空间, 程序就会抛出'内存溢出的错误
  * 例如: 不断创建对象/数组(大)
  * 问题: 运行出错, 程序停止
  * 解决: 减小申请内存, 及时释放内存
* 关系
  * 内存泄露如果不断累积, 就有可能导致内存溢出的错误
## 线程机制与事件机制
* 线程与进程
  * 进程:
    * 程序的一次执行, 它占有一片独有的内存空间
    * 可以通过windows任务管理器查看进程
  * 线程:
    * 是进程内的一个独立执行单元
    * 是程序执行的一个完整流程
    * 是CPU的最小的调度单元
  * 关系
    * 一个进程至少有一个线程(主)
    * 程序是在某个进程中的某个线程执行的
* 阻塞与非阻塞
  * I/O (了解)
    * 阻塞I/O: 调用时, 应用程序需要等待IO完成才返回结果
    * 非阻塞I/O: 调用之后立即返回, 需要通过轮询得到IO的结果数据
  * 非I/O
    * 阻塞: 调用函数导致所在的线程暂停, 不能继续执行 --->alert()
    * 非阻塞 : 其它代码(绝大部分)
* 同步与异步
  * 它们描述的是调用执行功能程序的方式
  * 同步: 调用一个函数，在没有得到结果之前，该调用就不返回 (绝大部分)
  * 异步: 调用一个函数会立即返回, 但此时还没有得到结果,   (回调函数)
          结果是通过回调函数的形式交给调用者
* 并发与并行(了解)
  * 并行: 多个事件在同一时刻发生
  * 并发: 指多个事件在同一时间间隔内发生

* js线程
  * js是单线程执行的(回调函数也是在主线程)
  * H5提出了实现多线程的方案: Web Workers   --->Worker
  * 只能是主线程更新界面
  * 在worker线程中, 全局对象不再是window

* 定时器问题:
  * 定时器并不真正完全定时
  * 如果在主线程执行了一个长时间的操作, 可能导致延时才处理
  * 区别setTimeout与setInterval
  
* 事件处理机制(图)
  * 所有代码分类
    * 初始化执行代码: 包含绑定dom事件监听, 设置定时器, 发送ajax请求的代码
    * 回调执行代码: 处理回调逻辑
  * js引擎执行代码的基本流程: 初始化代码===>回调代码
  * 模型的2个重要组成部分:
    * 事件管理模块
    * 回调队列
  * 模型的运转流程
    * 执行初始化代码, 将事件回调函数交给对应模块管理
    * 当事件发生时, 管理模块会将回调函数及其数据添加到回调列队中
    * 只有当初始化代码执行完后(可能要一定时间), 才会遍历读取回调队列中的回调函数执行
  
* H5 Web Workers
  * 可以让js在分线程执行
  * Worker
    ```
    var worker = new Worker('worker.js');
    worker.onMessage = function(event){event.data} : 用来接收另一个线程发送过来的数据的回调
    worker.postMessage(data1) : 向另一个线程发送数据
    ```
  * 不足:
    * worker内代码不能操作DOM更新UI
    * 不能跨域加载JS
    * 不是每个浏览器都支持这个新特性   
# VUE
## vue基础
    * Vue.js是什么?
    * 一位华裔前Google工程师开发的前端js库
    * 一个MVVM的框架
    * 核心概念
      * 数据绑定
      * 组件
  * 与angular.js类似的是声明式开发，但性能高于angular，体积小很多, 比较适合移动端开发
  * 它本身不是全能框架, 只关注UI, 如果需要router/ajax, 可以使用对应插件或使用别的库来实现
  
* 基本使用
	* 引入vue.js
	* 创建Vue对象(vm), 指定选项(配置)对象
		* el : 指定dom标签容器的选择器
		* data : 指定初始化状态属性数据的对象
		        对象/函数(返回一个对象)
	* 页面中
		* 使用v-model: 实现双向数据绑定
		* 使用{{}}: 显示数据
	
* Vue对象的选项
	* el
	  * 指定dom标签容器的选择器
		* Vue就会管理对应的标签及其子标签
	* data
	  * 对象或函数类型
		* 指定初始化状态属性数据的对象
		* vue对象可以直接访问其属性
		* 页面中可以直接访问使用
		* 数据代理: 由vm对象来代理对data中所有属性的操作(读/写)
	* methods
		* 包含多个方法的对象
		* 供页面中的事件指令来绑定回调
		* 回调函数默认有event参数, 但也可以指定自己的参数
		* 所有的方法由vue对象来调用, 访问data中的属性直接使用this.xxx
	* computed
		* 包含多个方法的对象
		* 对状态属性进行计算返回一个新的数据, 供页面获取显示
		* 一般情况下是相当于是一个只读的属性
		* 利用set/get方法来实现属性数据的计算读取, 同时监视属性数据的变化
		* 如何给对象定义get/set属性
		  * 在创建对象时指定: get name () {return xxx} / set name (value) {}
		  * 对象创建之后指定: Object.defineProperty(obj, age, {get(){}, set(value){}})
	* watch
	  * Vue.$watch()
		* 包含多个属性监视的对象
		* 分为一般监视和深度监视
      ```
      'xxx' : {
        deep : true,
        handler : fun(value)
      }
      ```

* 扩展数组
  * 对数组的常用方法进行了包装(用于数据绑定)
	* $remove(item) : 删除数组中对应的元素
	* $set(index, ele) : 给数组中指定下标指定对应的元素 

* 过渡
  * 利用vue去操控css的动画
  * transition/animation
  * 使用
    * <div v-show="a"  v-if="a" transition="xxx">
    * 定义css样式
      * .xxx-transition: 在其中去指定transition/animation
      * .xxx-enter
      * .xxx-leave
  * 动画的钩子函数

* 生命周期
  * vm/组件对象
  * 生命周期图
  * 主要的生命周期函数(钩子)
    * created(): 启动异步任务(发送ajax请求, 启动定时器)
    * beforeDestroy(): 做一些收尾的工作

* 页面指令
	* v-text/v-html: 指定标签体
    * v-text : 当作纯文本
		* v-html : 将value作为html标签来解析
	* v-if v-else v-show
		* v-if : 如果vlaue为true, 当前标签会输出在页面中
		* v-else : 与v-if一起使用, 如果value为false, 将当前标签输出到页面中
		* v-show: 就会在标签中添加display样式, 如果vlaue为true, display=block, 否则是none
	* v-for : 遍历
		* 遍历数组 : v-for="person in persons"   $index
		* 遍历对象 : v-for="value in person"   $key
	* v-on : 绑定事件监听
		* v-on:事件名, 可以缩写为: @事件名
		* 监视具体的按键: @keyup.keyCode   @keyup.enter
		* 阻止事件的冒泡和事件默认行为: @click.stop   @click.prevent
		* 隐含对象: $event
	* v-bind : 强制绑定解析表达式  
		* 很多属性值是不支持表达式的, 就可以使用v-bind
		* 可以缩写为:  :id='name'
		* :class
		  * :class="a"
			* :class="{classA : isA, classB : isB}"
			* :class="[classA, classB]"
		* :style
			:style="{color : color}"
         :value='2' 可以将字符串变为数字
	* v-model
		* 双向数据绑定
      v-module.number 将接收的数据转为number类型
	* v-el : 标识某个标签
		* v-el:xxx
		* 读取得到标签对象: this.$els.xxx
	
* 过滤器
  * 内置
    * capitalize : 首字母大小
    * uppercase : 全部大写
    * lowercase : 全部小写
    * currency : 货币化
    * pluralize : 单数/复数处理
    * json : json格式化

    * limitBy : 限定数组的部分元素(下标)
    * filterBy : 限定数组的部分元素(值)
    * orderBy : 对数组进行排序
  * 自定义
  * 全局过滤器
    ```
    Vue.filter('过滤器名', function(value, xxx, yyy) {
      //处理逻辑
      return result;
    })
    ```
  * 局部过滤器
    ```
    new Vue({
      filters : {
        '过滤器名' : function(value, xxx, yyy) {
            //处理逻辑
            return result;
        }
      }
    })
    ```
* 指令
  * 内置
    * v:text : 更新元素的 textContent
    * v-html : 更新元素的 innerHTML
    * v-if : 如果为true, 当前标签才会输出到页面
    * v-else: 如果为false, 当前标签才会输出到页面
    * v-show : 通过控制display样式来控制显示/隐藏
    * v-for : 遍历数组/对象
    * v-on : 绑定事件监听, 一般简写为@
    * v-bind : 强制绑定解析表达式, 可以省略v-bind
    * v-model : 双向数据绑定
    * v-el : 为某个元素注册一个唯一标识, vue对象通过$els属性访问这个元素对象
    * v-cloak : 使用它防止闪现表达式, 与css配合: [v-cloak] { display: none }
  * 自定义
    * 注册全局指令
      ```
      Vue.directive('my-directive', function(value){
        this.el.innerHTML = value.toUpperCase();
      })
      ```
    * 注册局部指令
      ```
      directives : {
        'my-directive' : function(value) {
          this.el.innerHTML = value;
        }
      }
      ```
    * 使用指令:
      ```
      v-my-directive='xxx'
      ```
## vue高级
### 脚手架文件结构

	├── node_modules 
	├── public
	│   ├── favicon.ico: 页签图标
	│   └── index.html: 主页面
	├── src
	│   ├── assets: 存放静态资源
	│   │   └── logo.png
	│   │── component: 存放组件
	│   │   └── HelloWorld.vue
	│   │── App.vue: 汇总所有组件
	│   │── main.js: 入口文件
	├── .gitignore: git版本管制忽略的配置
	├── babel.config.js: babel的配置文件
	├── package.json: 应用包配置文件 
	├── README.md: 应用描述文件
	├── package-lock.json：包版本控制文件

### 关于不同版本的Vue

1. vue.js与vue.runtime.xxx.js的区别：
    1. vue.js是完整版的Vue，包含：核心功能 + 模板解析器。
    2. vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。
2. 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。

### vue.config.js配置文件

1. 使用vue inspect > output.js可以查看到Vue脚手架的默认配置。
2. 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh

### ref属性

1. 被用来给元素或子组件注册引用信息（id的替代者）
2. 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc）
3. 使用方式：
    1. 打标识：```<h1 ref="xxx">.....</h1>``` 或 ```<School ref="xxx"></School>```
    2. 获取：```this.$refs.xxx```

### props配置项

1. 功能：让组件接收外部传过来的数据

2. 传递数据：```<Demo name="xxx"/>```

3. 接收数据：

    1. 第一种方式（只接收）：```props:['name'] ```

    2. 第二种方式（限制类型）：```props:{name:String}```

    3. 第三种方式（限制类型、限制必要性、指定默认值）：

        ```js
        props:{
        	name:{
        	type:String, //类型
        	required:true, //必要性
        	default:'老王' //默认值
        	}
        }
        ```

    > 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。

### mixin(混入)

1. 功能：可以把多个组件共用的配置提取成一个混入对象

2. 使用方式：

    第一步定义混合：

    ```
    {
        data(){....},
        methods:{....}
        ....
    }
    ```

    第二步使用混入：

    ​	全局混入：```Vue.mixin(xxx)```
    ​	局部混入：```mixins:['xxx']	```

### 插件

1. 功能：用于增强Vue

2. 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。

3. 定义插件：

    ```js
    对象.install = function (Vue, options) {
        // 1. 添加全局过滤器
        Vue.filter(....)
    
        // 2. 添加全局指令
        Vue.directive(....)
    
        // 3. 配置全局混入(合)
        Vue.mixin(....)
    
        // 4. 添加实例方法
        Vue.prototype.$myMethod = function () {...}
        Vue.prototype.$myProperty = xxxx
    }
    ```

4. 使用插件：```Vue.use()```

### scoped样式

1. 作用：让样式在局部生效，防止冲突。
2. 写法：```<style scoped>```

### 总结TodoList案例

1. 组件化编码流程：

    ​	(1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。

    ​	(2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用：

    ​			1).一个组件在用：放在组件自身即可。

    ​			2). 一些组件在用：放在他们共同的父组件上（<span style="color:red">状态提升</span>）。

    ​	(3).实现交互：从绑定事件开始。

2. props适用于：

    ​	(1).父组件 ==> 子组件 通信

    ​	(2).子组件 ==> 父组件 通信（要求父先给子一个函数,子组件调用函数将子组件的数据作为函数的参数，从而将子组件的数据传入父组件）

3. 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！

4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。

### webStorage

1. 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）

2. 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。

3. 相关API：

    1. ```xxxxxStorage.setItem('key', 'value');```
        				该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。

    2. ```xxxxxStorage.getItem('person');```

        ​		该方法接受一个键名作为参数，返回键名对应的值。

    3. ```xxxxxStorage.removeItem('key');```

        ​		该方法接受一个键名作为参数，并把该键名从存储中删除。

    4. ``` xxxxxStorage.clear()```

        ​		该方法会清空存储中的所有数据。

4. 备注：

    1. SessionStorage存储的内容会随着浏览器窗口关闭而消失。
    2. LocalStorage存储的内容，需要手动清除才会消失。
    3. ```xxxxxStorage.getItem(xxx)```如果xxx对应的value获取不到，那么getItem的返回值是null。
    4. ```JSON.parse(null)```的结果依然是null。

### 组件的自定义事件

1. 一种组件间通信的方式，适用于：<strong style="color:red">子组件 ===> 父组件</strong>

2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（<span style="color:red">事件的回调在A中</span>）。

3. 绑定自定义事件：

    1. 第一种方式，在父组件中：```<Demo @atguigu="test"/>```  或 ```<Demo v-on:atguigu="test"/>```

    2. 第二种方式，在父组件中：

        ```js
        <Demo ref="demo"/>
        ......
        mounted(){
           this.$refs.xxx.$on('atguigu',this.test)
        }
        ```

    3. 若想让自定义事件只能触发一次，可以使用```once```修饰符，或```$once```方法。

4. 触发自定义事件：```this.$emit('atguigu',数据)```		

5. 解绑自定义事件```this.$off('atguigu')```

6. 组件上也可以绑定原生DOM事件，需要使用```native```修饰符。

7. 注意：通过```this.$refs.xxx.$on('atguigu',回调)```绑定自定义事件时，回调<span style="color:red">要么配置在methods中</span>，<span style="color:red">要么用箭头函数</span>，否则this指向会出问题！

### 全局事件总线（GlobalEventBus）

1. 一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。

2. 安装全局事件总线：

   ```js
   new Vue({
   	......
   	beforeCreate() {
   		Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm
   	},
       ......
   }) 
   ```

3. 使用事件总线：

   1. 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的<span style="color:red">回调留在A组件自身。</span>

      ```js
      methods(){
        demo(data){......}
      }
      ......
      mounted() {
        this.$bus.$on('xxxx',this.demo)
      }
      ```

   2. 提供数据：```this.$bus.$emit('xxxx',数据)```

4. 最好在beforeDestroy钩子中，用$off去解绑<span style="color:red">当前组件所用到的</span>事件。

### 消息订阅与发布（pubsub）

1.   一种组件间通信的方式，适用于<span style="color:red">任意组件间通信</span>。

2. 使用步骤：

   1. 安装pubsub：```npm i pubsub-js```

   2. 引入: ```import pubsub from 'pubsub-js'```

   3. 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的<span style="color:red">回调留在A组件自身。</span>

      ```js
      methods(){
        demo(data){......}
      }
      ......
      mounted() {
        this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息
      }
      ```

   4. 提供数据：```pubsub.publish('xxx',数据)```

   5. 最好在beforeDestroy钩子中，用```PubSub.unsubscribe(pid)```去<span style="color:red">取消订阅。</span>
	
### nextTick

1. 语法：```this.$nextTick(回调函数)```
2. 作用：在下一次 DOM 更新结束后执行其指定的回调。
3. 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。

### Vue封装的过度与动画

1. 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。

2. 图示：<img src="https://img04.sogoucdn.com/app/a/100520146/5990c1dff7dc7a8fb3b34b4462bd0105" style="width:60%" />

3. 写法：

   1. 准备好样式：

      - 元素进入的样式：
        1. v-enter：进入的起点
        2. v-enter-active：进入过程中
        3. v-enter-to：进入的终点
      - 元素离开的样式：
        1. v-leave：离开的起点
        2. v-leave-active：离开过程中
        3. v-leave-to：离开的终点

   2. 使用```<transition>```包裹要过度的元素，并配置name属性：

      ```vue
      <transition name="hello">
      	<h1 v-show="isShow">你好啊！</h1>
      </transition>
      ```

   3. 备注：若有多个元素需要过度，则需要使用：```<transition-group>```，且每个元素都要指定```key```值。

### vue脚手架配置代理

#### 方法一

​	在vue.config.js中添加如下配置：

```js
devServer:{
  proxy:"http://localhost:5000"
}
```
脚手架开启的服务器为8080，代理服务器为8080，数据的服务器为5000
过程为：
8080向代理服务器8080请求数据，代理服务器向5000请求数据
说明：
说明：

1. 优点：配置简单，请求资源时直接发给前端（8080）即可。
2. 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。
3. 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源）

#### 方法二

​	编写vue.config.js配置具体代理规则：

```js
module.exports = {
	devServer: {
      proxy: {
      '/api1': {// 匹配所有以 '/api1'开头的请求路径 http:localhost:8080/api1/student 不加前缀不走代理服务器
        target: 'http://localhost:5000',// 代理目标的基础路径
        changeOrigin: true,//(用于控制请求头中的host值)说代理服务器的端口与请求数据服务器端口相同
        pathRewrite: {'^/api1': ''}//重写路径
      },
      '/api2': {// 匹配所有以 '/api2'开头的请求路径
        target: 'http://localhost:5001',// 代理目标的基础路径
        changeOrigin: true,
        pathRewrite: {'^/api2': ''}
      }
    }
  }
}
/*
   changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000
   changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080
   changeOrigin默认值为true
*/
```

说明：

1. 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。
2. 缺点：配置略微繁琐，请求资源时必须加前缀。

### 插槽
1. 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 <strong style="color:red">父组件 ===> 子组件</strong> 。

2. 分类：默认插槽、具名插槽、作用域插槽

3. 使用方式：

   1. 默认插槽：

      ```vue
      父组件中：
              <Category>
                 <div>html结构1</div>
              </Category>
      子组件中：
              <template>
                  <div>
                     <!-- 定义插槽 -->
                     <slot>插槽默认内容...</slot>
                  </div>
              </template>
      ```

   2. 具名插槽：

      ```vue
      父组件中：
              <Category>
                  <template slot="center">
                    <div>html结构1</div>
                  </template>
      
                  <template v-slot:footer>
                     <div>html结构2</div>
                  </template>
              </Category>
      子组件中：
              <template>
                  <div>
                     <!-- 定义插槽 -->
                     <slot name="center">插槽默认内容...</slot>
                     <slot name="footer">插槽默认内容...</slot>
                  </div>
              </template>
      ```

   3. 作用域插槽：

      1. 理解：<span style="color:red">数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。</span>（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）

      2. 具体编码：

         ```vue
         父组件中：
         		<Category>
         			<template scope="scopeData">
         				<!-- 生成的是ul列表 -->
         				<ul>
         					<li v-for="g in scopeData.games" :key="g">{{g}}</li>
         				</ul>
         			</template>
         		</Category>
         
         		<Category>
         			<template slot-scope="scopeData">
         				<!-- 生成的是h4标题 -->
         				<h4 v-for="g in scopeData.games" :key="g">{{g}}</h4>
         			</template>
         		</Category>
         子组件中：
                 <template>
                     <div>
                         <slot :games="games"></slot>
                     </div>
                 </template>
         		
                 <script>
                     export default {
                         name:'Category',
                         props:['title'],
                         //数据在子组件自身
                         data() {
                             return {
                                 games:['红色警戒','穿越火线','劲舞团','超级玛丽']
                             }
                         },
                     }
                 </script>
         ```
   ```
   
   ```
### 路由
   vue-router4只能在vue3中使用，vue-router3在vue2中使用
1. 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。
2. 前端路由：key是路径，value是组件。

#### 1.基本使用

1. 安装vue-router，命令：```npm i vue-router```

2. 应用插件：```Vue.use(VueRouter)```

3. 编写router配置项:

   ```js
   //引入VueRouter
   import VueRouter from 'vue-router'
   //引入Luyou 组件
   import About from '../components/About'
   import Home from '../components/Home'
   
   //创建router实例对象，去管理一组一组的路由规则
   const router = new VueRouter({
   	routes:[
   		{
   			path:'/about',
   			component:About
   		},
   		{
   			path:'/home',
   			component:Home
   		}
   	]
   })
   
   //暴露router
   export default router
   ```

4. 实现切换（active-class可配置高亮样式）

   ```vue
   <router-link active-class="active" to="/about">About</router-link>
   ```

5. 指定展示位置

   ```vue
   <router-view></router-view>
   ```

#### 2.几个注意点

1. 路由组件通常存放在```pages```文件夹，一般组件通常存放在```components```文件夹。
2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。
3. 每个组件都有自己的```$route```属性，里面存储着自己的路由信息。
4. 整个应用只有一个router，可以通过组件的```$router```属性获取到。

#### 3.多级路由（多级路由）

1. 配置路由规则，使用children配置项：

   ```js
   routes:[
   	{
   		path:'/about',
   		component:About,
   	},
   	{
   		path:'/home',
   		component:Home,
   		children:[ //通过children配置子级路由
   			{
   				path:'news', //此处一定不要写：/news
   				component:News
   			},
   			{
   				path:'message',//此处一定不要写：/message
   				component:Message
   			}
   		]
   	}
   ]
   ```

2. 跳转（要写完整路径）：

   ```vue
   <router-link to="/home/news">News</router-link>
   ```

#### 4.路由的query参数

1. 传递参数

   ```vue
   <!-- 跳转并携带query参数，to的字符串写法 -->
   <router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link>
   				
   <!-- 跳转并携带query参数，to的对象写法 -->
   <router-link 
   	:to="{
   		path:'/home/message/detail',
   		query:{
   		   id:666,
               title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

2. 接收参数：

   ```js
   $route.query.id
   $route.query.title
   ```

#### 5.命名路由

1. 作用：可以简化路由的跳转。

2. 如何使用

   1. 给路由命名：

      ```js
      {
      	path:'/demo',
      	component:Demo,
      	children:[
      		{
      			path:'test',
      			component:Test,
      			children:[
      				{
                            name:'hello' //给路由命名
      					path:'welcome',
      					component:Hello,
      				}
      			]
      		}
      	]
      }
      ```

   2. 简化跳转：

      ```vue
      <!--简化前，需要写完整的路径 -->
      <router-link to="/demo/test/welcome">跳转</router-link>
      
      <!--简化后，直接通过名字跳转 -->
      <router-link :to="{name:'hello'}">跳转</router-link>
      
      <!--简化写法配合传递参数 -->
      <router-link 
      	:to="{
      		name:'hello',
      		query:{
      		   id:666,
                  title:'你好'
      		}
      	}"
      >跳转</router-link>
      ```

#### 6.路由的params参数

1. 配置路由，声明接收params参数

   ```js
   {
   	path:'/home',
   	component:Home,
   	children:[
   		{
   			path:'news',
   			component:News
   		},
   		{
   			component:Message,
   			children:[
   				{
   					name:'xiangqing',
   					path:'detail/:id/:title', //使用占位符声明接收params参数
   					component:Detail
   				}
   			]
   		}
   	]
   }
   ```

2. 传递参数

   ```vue
   <!-- 跳转并携带params参数，to的字符串写法 -->
   <router-link :to="/home/message/detail/666/你好">跳转</router-link>
   				
   <!-- 跳转并携带params参数，to的对象写法 -->
   <router-link 
   	:to="{
   		name:'xiangqing',
   		params:{
   		   id:666,
               title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

   > 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！

3. 接收参数：

   ```js
   $route.params.id
   $route.params.title
   ```

#### 7.路由的props配置

​	作用：让路由组件更方便的收到参数

```js
{
	name:'xiangqing',
	path:'detail/:id',
	component:Detail,

	//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
	// props:{a:900}

	//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
	// props:true
	
	//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
	props(route){
		return {
			id:route.query.id,
			title:route.query.title
		}
	}
}
```

#### 8.的replace属性

1. 作用：控制路由跳转时操作浏览器历史记录的模式
2. 浏览器的历史记录有两种写入方式：分别为```push```和```replace```，```push```是追加历史记录，```replace```是替换当前记录。路由跳转时候默认为```push```
3. 如何开启```replace```模式：```<router-link replace .......>News</router-link>```

#### 9.编程式路由导航

1. 作用：不借助```<router-link> ```实现路由跳转，让路由跳转更加灵活

2. 具体编码：

   ```js
   //$router的两个API
   this.$router.push({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   
   this.$router.replace({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   this.$router.forward() //前进
   this.$router.back() //后退
   this.$router.go() //可前进也可后退
   ```

#### 10.缓存路由组件

1. 作用：让不展示的路由组件保持挂载，不被销毁。

2. 具体编码：

   ```vue
   <keep-alive include="News"> 
       <router-view></router-view>
   </keep-alive>
   ```

#### 11.两个新的生命周期钩子

1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。
2. 具体名字：
   1. ```activated```路由组件被激活时触发。
   2. ```deactivated```路由组件失活时触发。

#### 12.路由守卫

1. 作用：对路由进行权限控制

2. 分类：全局守卫、独享守卫、组件内守卫

3. 全局守卫:

   ```js
   //全局前置守卫：初始化时执行、每次路由切换前执行
   router.beforeEach((to,from,next)=>{
   	console.log('beforeEach',to,from)
   	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   		if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则
   			next() //放行
   		}else{
   			alert('暂无权限查看')
   			// next({name:'guanyu'})
   		}
   	}else{
   		next() //放行
   	}
   })
   
   //全局后置守卫：初始化时执行、每次路由切换后执行
   router.afterEach((to,from)=>{
   	console.log('afterEach',to,from)
   	if(to.meta.title){ 
   		document.title = to.meta.title //修改网页的title
   	}else{
   		document.title = 'vue_test'
   	}
   })
   ```

4. 独享守卫:

   ```js
   beforeEnter(to,from,next){
   	console.log('beforeEnter',to,from)
   	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   		if(localStorage.getItem('school') === 'atguigu'){
   			next()
   		}else{
   			alert('暂无权限查看')
   			// next({name:'guanyu'})
   		}
   	}else{
   		next()
   	}
   }
   ```

5. 组件内守卫：

   ```js
   //进入守卫：通过路由规则，进入该组件时被调用
   beforeRouteEnter (to, from, next) {
   },
   //离开守卫：通过路由规则，离开该组件时被调用
   beforeRouteLeave (to, from, next) {
   }
   ```

#### 13.路由器的两种工作模式



1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。
2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。
3. hash模式：
   1. 地址中永远带着#号，不美观 。
   2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
   3. 兼容性较好。
4. history模式：
   1. 地址干净，美观 。
   2. 兼容性和hash模式相比略差。
   3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。
## vue-cli插件使用
* 说明:
  * vue-cli是vue官方提供的脚手架工具包
  * github: https://github.com/vuejs/vue-cli

* 使用vue-cli快速创建工程化项目
  * 使用基于webpack的简单模板创建项目: webpack-simple_demo
    ```
    npm install -g vue-cli    //下载脚手架包
    vue init webpack-simple webpack-simple_demo   //下载模板
    vue init webpack-simple#1.0 webpack-simple_demo   //下载模板
    cd webpack-simple_demo
    cyarn/npm install
    npm run dev
    访问: http://localhost:8080/
    ```
  * 使用基于webpack的完整模板创建项目: webpack_demo
    ```
    vue init webpack#1.0 webpack_demo
    cd webpack_demo
    cyarn/npm install
    npm run dev
    访问: http://localhost:8080/
    ```
* 模板项目的结构
  ```
  |-- build : webpack相关的配置文件夹(基本不需要修改)
    |-- dev-server.js : 通过express启动后台服务器
  |-- config: webpack相关的配置文件夹(基本不需要修改)
    |-- index.js: 指定的后台服务的端口号和静态资源文件夹
  |-- node_modules
  |-- src : 源码文件夹
    |-- components: vue组件及其相关资源文件夹
    |-- app.vue: 应用根主组件
    |-- main.js: 应用入口js
  |-- static: 静态资源文件夹
  |-- .babelrc: babel的配置文件
  |-- .editorconfig: 通过编辑器的编码/格式进行一定的配置
  |-- .eslintignore: eslint检查忽略的配置
  |-- .eslintrc.js: eslint检查的配置
  |-- .gitignore: git版本管制忽略的配置
  |-- index.html: 主页面文件
  |-- package.json: 应用包配置文件 
  |-- README.md: 应用描述说明的readme文件
  ```

* 编码测试与打包发布项目
  * 编码测试:
    * npm run dev
    * 访问: http://localhost:8080
    * 编码, 自动编译打包(HMR), 查看效果
  * 打包发布
    * npm run build
    * npm install -g pushstate-server
    * pushstate-server dist
    * 访问: http://localhost:9000
## vue-router插件使用
* 说明
  * 官方提供的用来实现SPA的插件
  * github: https://github.com/vuejs/vue-router
  * 对应vue1.x的版本为: 0.7.13
* 下载和引入
  ```
  npm install vue-router@0.7.13 --save
  import VueRouter from 'vue-router'
  ```
* 相关API说明
  * VueRouter(): 构建函数, 用来创建路由器对象
    * 配置: 在创建对象时可以指定一个配置对象
      ```
      new VueRouter({
        linkActiveClass: 'active', //指定当前路由链接的样式名
        history: true //去掉#!
      })
      ```
    * map(): 映射路由
      ```
      router.map({
        '/about': {
          component: About
        },
        '/home': {
          component: Home
        }
      })
      ```
    * start(): 启动应用
      ```
      router.start(App, '#app')
      ```
    * go(): 请求指定路由
      ```
      router.go('/about')
      ```
  * 指令与组件:
    * v-link: 用来指定路由路径
      ```
      <a v-link='{path:"/about"}'>About</a>
      ```
    * <router-view>: 用来显示当前路由组件界面
      ```
      <router-view></router-view>
      ```
* 实现简单路由
  * 路由组件:
    * home.vue
    * about.vue
  * 应用组件: App.vue
    ```
    <div>
      <!--路由链接-->
      <a v-link="{path:'/about'}">About</a>
      <a v-link="{path:'/home'}">Home</a>
      <!--用于渲染当前路由组件-->
      <router-view></router-view>  
    </div>
    ```
  * 入口js: main.js
    ```
    import Vue from 'vue'
    import VueRouter from 'vue-router'
    import app from './components/app.vue'
    
    //使用插件
    Vue.use(VueRouter)
    
    //创建用来映射路由的路由器对象
    const router = new VueRouter({
      linkActiveClass: 'active', //指定当前路由链接的样式名
      history: true //去掉#!
    })
    
    //配置路由
    router.map({
      '/about': {component: about},
      '/home': {component: home}
    })
    
    //启动应用
    router.start(app, '#app')
    
    //初始请求一个路由
    router.go('/about')
    ```
* 实现嵌套路由
  * 配置嵌套路由
    ```
    subRoutes: {
      '/news': {
        component: news
      }
    }
    ```
  * 路由路径
    ```
    <a v-link="{path: '/home/news'}">News</a>
    ```
* 路由请求携带参数
  * 配置路由
    ```
    subRoutes: {
      '/mdetail/:id': {
        component: messageDetail
      }
    }
    ```
  * 路由路径
    ```
    <a v-link="{path: '/home/message/mdetail/2'}">{{m.title}}</a>
    ```
  * 路由组件中读取请求参数
    ```
    {{$route.params.id}}
    ```
* <route-view>使用
  * 参数keep-alive属性实现路由界面的缓存
  * 通过标签属性可动态向路由组件内部传递数据
    ```
    <router-view keep-alive :msg="msg"></router-view>
    ```
# vue组件化开发
* vue组件的定义与使用
  * 一个.vue文件就是一个vue组件
  * 组成(3个部分)
    * 模板页面: 
      ```
      <template>
        页面模板
      </template>
      ```
    * JS默认模块对象: 
      ```
      <script>
        export default {
          data() {return {}},
          methods: {},
          computed: {},
          components: {}
        }
      </script>
      ```
    * 页面样式: 
      ```
      <style scoped>  //scoped代表样式只针对当前组件的模板页面
        样式定义
      </style>
      ```
  * 基本使用
    在父组件对象的components属性中配置子组件(将组件映射成标签)
    ```
    <template>
      <hello tt='abc'>
    </template>
    <script>
      import Hello from './components/Hello'
      export default {
        components: {
          Hello
        }
      }
    </script>
    ```
  * 关于标签名与标签属性名书写问题:
    * 标签名与标签属性名不区分大小写
    * 标签名: 如果组件名是XxxYyy, 标签名必须为<xxx-yyy>
    * 属性名: 如果标签属性名为xxx-yyy, 组件得到的属性名为: xxxYyy
  
* 组件化编码的基本流程
  * 拆分界面, 抽取组件
  * 编写静态组件, 并使用
  * 编写动态组件, 并使用
    * 初始化数据, 动态显示初始化界面
    * 响应用户操作
  
* 组件间通信
  * 组件通信的2种方式
    * props
    * vue的自定义事件机制
  * 基本原则: 不要在子组件中直接修改父组件的状态数据
  * 使用props
    * 组件标签: <my-component name='tom' :age='myAge' :set-name='setName'></my-component>
    * 组件: MyComponent
      * 在组件内声明所有的props
        ```
        //方式一: 只指定名称
        props: ['name', 'age', 'setName']
        //方式二: 指定名称和类型
        props: {
          name: String,
          age: Number,
          setNmae: Function
        }
        //方式三: 指定名称/类型/必要性/默认值
        props: {
          name: {type: String, required: true, default:xxx},
        }
        ```
      * 所有props的属性都会成为component对象的属性, 模板页面可以直接引用
  * 使用vue的自定义事件机制
    * 绑定事件监听
      * 方式一: 通过$on()
        ```
        this.$on('delete_todo', function (todo) {
          this.deleteTodo(todo)
        })
        ```
      * 方式二: 通过events选项
        ```
        events: {
          'delete_todo': function (todo) {
            this.deleteTodo(todo)
          }
        },
        ```
      * 方式三: 通过v-on绑定
        ```
        @delete_todo="deleteTodo"
        ```
    * 触发事件(3种情况)
      ```
      this.$emit(eventName, data): 在当前组件触发事件
      this.$dispatch(eventName, data): 分给父辈组件(冒泡)
      this.$broadcast(eventName, data): 广播给后代组件
      ```
# Vuex

## 1.概念
      Vue2与Vuex3 匹配  Vue3与Vuex4 匹配
​		在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。

## 2.何时使用？

​		多个组件需要共享数据时

## 3.搭建vuex环境

1. 创建文件：```src/store/index.js```

   ```js
   //引入Vue核心库
   import Vue from 'vue'
   //引入Vuex
   import Vuex from 'vuex'
   //应用Vuex插件
   Vue.use(Vuex)
   
   //准备actions对象——响应组件中用户的动作
   const actions = {}
   //准备mutations对象——修改state中的数据
   const mutations = {}
   //准备state对象——保存具体的数据
   const state = {}
   
   //创建并暴露store
   export default new Vuex.Store({
   	actions,
   	mutations,
   	state
   })
   ```

2. 在```main.js```中创建vm时传入```store```配置项

   ```js
   ......
   //引入store
   import store from './store'
   ......
   
   //创建vm
   new Vue({
   	el:'#app',
   	render: h => h(App),
   	store
   })
   ```

##    4.基本使用

1. 初始化数据、配置```actions```、配置```mutations```，操作文件```store.js```

   ```js
   //引入Vue核心库
   import Vue from 'vue'
   //引入Vuex
   import Vuex from 'vuex'
   //引用Vuex
   Vue.use(Vuex)
   
   const actions = {
       //响应组件中加的动作
   	jia(context,value){
   		// console.log('actions中的jia被调用了',miniStore,value)
   		context.commit('JIA',value)
   	},
   }
   
   const mutations = {
       //执行加
   	JIA(state,value){
   		// console.log('mutations中的JIA被调用了',state,value)
   		state.sum += value
   	}
   }
   
   //初始化数据
   const state = {
      sum:0
   }
   
   //创建并暴露store
   export default new Vuex.Store({
   	actions,
   	mutations,
   	state,
   })
   ```

2. 组件中读取vuex中的数据：```$store.state.sum```

3. 组件中修改vuex中的数据：```$store.dispatch('action中的方法名',数据)``` 或 ```$store.commit('mutations中的方法名',数据)```
  dispatch()数据参数只能传递一个
   >  备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写```dispatch```，直接编写```commit```

## 5.getters的使用

1. 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。

2. 在```store.js```中追加```getters```配置

   ```js
   ......
   
   const getters = {
   	bigSum(state){
   		return state.sum * 10
   	}
   }
   
   //创建并暴露store
   export default new Vuex.Store({
   	......
   	getters
   })
   ```

3. 组件中读取数据：```$store.getters.bigSum```

## 6.四个map方法的使用

1. <strong>mapState方法：</strong>用于帮助我们映射```state```中的数据为计算属性

   ```js
   computed: {
       //借助mapState生成计算属性：sum、school、subject（对象写法）
        ...mapState({sum:'sum',school:'school',subject:'subject'}),
            
       //借助mapState生成计算属性：sum、school、subject（数组写法）
       ...mapState(['sum','school','subject']),
   },
   ```

2. <strong>mapGetters方法：</strong>用于帮助我们映射```getters```中的数据为计算属性

   ```js
   computed: {
       //借助mapGetters生成计算属性：bigSum（对象写法）
       ...mapGetters({bigSum:'bigSum'}),
   
       //借助mapGetters生成计算属性：bigSum（数组写法）
       ...mapGetters(['bigSum'])
   },
   ```

3. <strong>mapActions方法：</strong>用于帮助我们生成与```actions```对话的方法，即：包含```$store.dispatch(xxx)```的函数

   ```js
   methods:{
       //靠mapActions生成：incrementOdd、incrementWait（对象形式）
       ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
   
       //靠mapActions生成：incrementOdd、incrementWait（数组形式）
       ...mapActions(['jiaOdd','jiaWait'])
   }
   ```

4. <strong>mapMutations方法：</strong>用于帮助我们生成与```mutations```对话的方法，即：包含```$store.commit(xxx)```的函数

   ```js
   methods:{
       //靠mapActions生成：increment、decrement（对象形式）
       ...mapMutations({increment:'JIA',decrement:'JIAN'}),
       
       //靠mapMutations生成：JIA、JIAN（对象形式）
       ...mapMutations(['JIA','JIAN']),
   }
   ```

> 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。

## 7.模块化+命名空间
1. 模块化方法一(利用命名空间模块化)
      1. 目的：让代码更好维护，让多种数据分类更加明确。

      2. 修改```store.js```

         ```javascript
         const countAbout = {
           namespaced:true,//开启命名空间
           state:{x:1},
           mutations: { ... },
           actions: { ... },
           getters: {
             bigSum(state){
                return state.sum * 10
             }
           }
         }

         const personAbout = {
           namespaced:true,//开启命名空间
           state:{ ... },
           mutations: { ... },
           actions: { ... }
         }

         const store = new Vuex.Store({
           modules: {
             countAbout,
             personAbout
           }
         })
         ```

      3. 开启命名空间后，组件中读取state数据：

         ```js
         //方式一：自己直接读取
         this.$store.state.personAbout.list
         //方式二：借助mapState读取：
         ...mapState('countAbout',['sum','school','subject']),
         ```

      4. 开启命名空间后，组件中读取getters数据：

         ```js
         //方式一：自己直接读取
         this.$store.getters['personAbout/firstPersonName']
         //方式二：借助mapGetters读取：
         ...mapGetters('countAbout',['bigSum'])
         ```

      5. 开启命名空间后，组件中调用dispatch

         ```js
         //方式一：自己直接dispatch
         this.$store.dispatch('personAbout/addPersonWang',person)
         //方式二：借助mapActions：
         ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'})
         ```

      6. 开启命名空间后，组件中调用commit

         ```js
         //方式一：自己直接commit
         this.$store.commit('personAbout/ADD_PERSON',person)
         //方式二：借助mapMutations：
         ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}),
         ```
      注意：此方法两个小仓库完全独立，getters也是独立的
2. 模块化方法二
  moudel1.js:
      const actions={}
      const mutations={}
      const state={}
      const getters={}
      export default{
        actions,
        mutations,
        state,
        getters,
      }
   moudel2.js:
      const actions={}
      const mutations={}
      const state={}
      const getters={}
      export default{
        actions,
        mutations,
        state,
        getters,
      }
  store.js:
   //引入vue
   import Vue from 'vue'
   //引入vuex
   import Vuex from 'vuex'
   //引入小仓库moudel1.js、moudel2.js
   import home from './xxx/moudel1.js'
   import search from './xxx/moudel2.js'
   //创建store类的一个实例并对外暴露
   export default new Vuex.Store({
        //实现Vuex仓库模块化存储数据
        moudels:{
          //注册小仓库
          home,
          search
        }
   })
注意：此方法getters仓库公用，两个小仓库都能读取的到，state读取要加state.小仓库名.xxx
# vue-router路由

1. 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。
2. 前端路由：key是路径，value是组件。
3.  vue2 路由版本为3

## 1.基本使用

1. 安装vue-router，命令：```npm i vue-router```

2. 应用插件：```Vue.use(VueRouter)```

3. 编写router配置项:

   ```js
   //引入VueRouter
   import VueRouter from 'vue-router'
   //引入Luyou 组件
   import About from '../components/About'
   import Home from '../components/Home'
   
   //创建router实例对象，去管理一组一组的路由规则
   const router = new VueRouter({
   	routes:[
   		{
   			path:'/about',
   			component:About
   		},
   		{
   			path:'/home',
   			component:Home
   		}
   	]
   })
   
   //暴露router
   export default router
   ```

4. 实现切换（active-class可配置高亮样式）

   ```vue
   <router-link active-class="active" to="/about">About</router-link>
   ```

5. 指定展示位置

   ```vue
   <router-view></router-view>
   ```

## 2.几个注意点

1. 路由组件通常存放在```pages```文件夹，一般组件通常存放在```components```文件夹。
2. 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。
3. 每个组件都有自己的```$route```属性，里面存储着自己的路由信息。
4. 整个应用只有一个router，可以通过组件的```$router```属性获取到。

## 3.多级路由（多级路由）

1. 配置路由规则，使用children配置项：

   ```js
   routes:[
   	{
   		path:'/about',
   		component:About,
   	},
   	{
   		path:'/home',
   		component:Home,
   		children:[ //通过children配置子级路由
   			{
   				path:'news', //此处一定不要写：/news
   				component:News
   			},
   			{
   				path:'message',//此处一定不要写：/message
   				component:Message
   			}
   		]
   	}
   ]
   ```

2. 跳转（要写完整路径）：

   ```vue
   <router-link to="/home/news">News</router-link>
   ```

## 4.路由的query参数

1. 传递参数

   ```vue
   <!-- 跳转并携带query参数，to的字符串写法 -->
   <router-link :to="/home/message/detail?id=666&title=你好">跳转</router-link>
   				
   <!-- 跳转并携带query参数，to的对象写法 -->
   <router-link 
   	:to="{
   		path:'/home/message/detail',
   		query:{
   		   id:666,
               title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

2. 接收参数：

   ```js
   $route.query.id
   $route.query.title
   ```

## 5.命名路由

1. 作用：可以简化路由的跳转。

2. 如何使用

   1. 给路由命名：

      ```js
      {
      	path:'/demo',
      	component:Demo,
      	children:[
      		{
      			path:'test',
      			component:Test,
      			children:[
      				{
                            name:'hello' //给路由命名
      					path:'welcome',
      					component:Hello,
      				}
      			]
      		}
      	]
      }
      ```

   2. 简化跳转：

      ```vue
      <!--简化前，需要写完整的路径 -->
      <router-link to="/demo/test/welcome">跳转</router-link>
      
      <!--简化后，直接通过名字跳转 -->
      <router-link :to="{name:'hello'}">跳转</router-link>
      
      <!--简化写法配合传递参数 -->
      <router-link 
      	:to="{
      		name:'hello',
      		query:{
      		   id:666,
                  title:'你好'
      		}
      	}"
      >跳转</router-link>
      ```

## 6.路由的params参数

1. 配置路由，声明接收params参数

   ```js
   {
   	path:'/home',
   	component:Home,
   	children:[
   		{
   			path:'news',
   			component:News
   		},
   		{
   			component:Message,
   			children:[
   				{
   					name:'xiangqing',
   					path:'detail/:id/:title', //使用占位符声明接收params参数
   					component:Detail
   				}
   			]
   		}
   	]
   }
   ```

2. 传递参数

   ```vue
   <!-- 跳转并携带params参数，to的字符串写法 -->
   <router-link :to="/home/message/detail/666/你好">跳转</router-link>
   				
   <!-- 跳转并携带params参数，to的对象写法 -->
   <router-link 
   	:to="{
   		name:'xiangqing',
   		params:{
   		   id:666,
               title:'你好'
   		}
   	}"
   >跳转</router-link>
   ```

   > 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！

3. 接收参数：

   ```js
   $route.params.id
   $route.params.title
   ```

## 7.路由的props配置

​	作用：让路由组件更方便的收到参数

```js
{
	name:'xiangqing',
	path:'detail/:id',
	component:Detail,

	//第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件
	// props:{a:900}

	//第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件
	// props:true
	
	//第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件
	props(route){
		return {
			id:route.query.id,
			title:route.query.title
		}
	}
}
```

## 8.```<router-link>```的replace属性

1. 作用：控制路由跳转时操作浏览器历史记录的模式
2. 浏览器的历史记录有两种写入方式：分别为```push```和```replace```，```push```是追加历史记录，```replace```是替换当前记录。路由跳转时候默认为```push```
3. 如何开启```replace```模式：```<router-link replace .......>News</router-link>```

## 9.编程式路由导航

1. 作用：不借助```<router-link> ```实现路由跳转，让路由跳转更加灵活

2. 具体编码：

   ```js
   //$router的两个API
   this.$router.push({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   
   this.$router.replace({
   	name:'xiangqing',
   		params:{
   			id:xxx,
   			title:xxx
   		}
   })
   this.$router.forward() //前进
   this.$router.back() //后退
   this.$router.go() //可前进也可后退
   ```

## 10.缓存路由组件

1. 作用：让不展示的路由组件保持挂载，不被销毁。

2. 具体编码：

   ```vue
   <keep-alive include="News"> 
       <router-view></router-view>
   </keep-alive>
   ```

## 11.两个新的生命周期钩子

1. 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。
2. 具体名字：
   1. ```activated```路由组件被激活时触发。
   2. ```deactivated```路由组件失活时触发。

## 12.路由守卫

1. 作用：对路由进行权限控制

2. 分类：全局守卫、独享守卫、组件内守卫

3. 全局守卫:

   ```js
   //全局前置守卫：初始化时执行、每次路由切换前执行
   router.beforeEach((to,from,next)=>{
   	console.log('beforeEach',to,from)
   	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   		if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则
   			next() //放行
   		}else{
   			alert('暂无权限查看')
   			// next({name:'guanyu'})
   		}
   	}else{
   		next() //放行
   	}
   })
   
   //全局后置守卫：初始化时执行、每次路由切换后执行
   router.afterEach((to,from)=>{
   	console.log('afterEach',to,from)
   	if(to.meta.title){ 
   		document.title = to.meta.title //修改网页的title
   	}else{
   		document.title = 'vue_test'
   	}
   })
   ```

4. 独享守卫:

   ```js
   beforeEnter(to,from,next){
   	console.log('beforeEnter',to,from)
   	if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制
   		if(localStorage.getItem('school') === 'atguigu'){
   			next()
   		}else{
   			alert('暂无权限查看')
   			// next({name:'guanyu'})
   		}
   	}else{
   		next()
   	}
   }
   ```

5. 组件内守卫：

   ```js
   //进入守卫：通过路由规则，进入该组件时被调用
   beforeRouteEnter (to, from, next) {
   },
   //离开守卫：通过路由规则，离开该组件时被调用
   beforeRouteLeave (to, from, next) {
   }
   ```

## 13.路由器的两种工作模式



1. 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。
2. hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。
3. hash模式：
   1. 地址中永远带着#号，不美观 。
   2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。
   3. 兼容性较好。
4. history模式：
   1. 地址干净，美观 。
   2. 兼容性和hash模式相比略差。
   3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。使用 connect-history-api-fallback
 部署上线：打包vue资源 npm run build  生成dist文件夹  放到后端服务器static(有的名为public或src)文件夹
# HTTP相关
    1.浏览器端向服务器发送http请求（请求报文）
    2.后台服务器接收到请求后，向浏览器端返回http响应(响应报文)
    3.浏览器端接收到响应，解析显示响应体或调用回调函数
  ## 请求报文
    1.请求行 格式 method url  例如 GET/production_detail?id=2
    2.请求头(一般有多个请求头)
    Host：www.baidu.com
    Cookie：
    Content-Type：
    ……
    3.请求体(get请求没有请求体)
  ## 响应报文
    1.响应行 格式 ：status statusText   例如：200 ok 或 404not found
    2.响应头(一般有多个) 
    Set-Cookie：
    Content-Type：
    ……
    3.响应体
        html/json/css/图片……
  ## 常见状态码
    200 OK                   请求成功。一般用于GET和POST请求
    201 Created              已创建。成功请求并创建了新的资源
    401 Unauthorized         未授权/请求要求用户的身份认证
    404 Not Found            服务器无法根据客户端请求找到资源
    500 Internal Sever Error 服务器内部错误，无法完成请求
  ## 请求方式与请求参数
    1.请求方式 
        GET(索取):  从服务器端读取数据————查(R)
        POST(交差): 向服务器端添加新数据————增(C)
        PUT:        更新服务器端已存在的数据————改(U)
        DELETE：    删除服务器端数据————删(D)
    2.请求参数
        query参数(查询字符串参数)
            (1)参数包含在请求地址中，格式：/xxx?name=tom&age=18
            (2)敏感数据不要用query参数，因为参数为地址的一部分，比较危险
            (3)query 参数有称为查询字符串参数，编码形式为urlencoded
        params参数
            (1)参数包含在请求地址中，格式：http:localhost:8080/add_person/tom/18
            (2)敏感数据不要用query参数，因为参数为地址的一部分，比较危险
    3.请求体参数(body) 一般用于post
            (1)参数包含在请求体中，可通过浏览器开发工具查看
            (2)常用的两种格式
                格式一：urlencoded格式
                      例如：name=tom&age=18
                      对应请求头：Content-Type：application/x-www-form-urlencoded
                格式二：json格式
                      例如：{'name':'tom','age':18}
                      对应请求头：Content-Type：application/json
    4.注意事项：
        (1)GET请求不能携带请求体参数
        (2)理论上一次请求可以随意使用上述3种类型参数中的任意一种，甚至一次请求的三个参数用3种形式携带，但一般不这样做
        (3)"约定俗成"的规矩
            1.form表单发送post请求时:自动使用请求体参数，用urlencoded编码
            2.jequry 发送ajax-post请求时：自动使用请求体参数，用urlencoded编码
        (4) 开发中请求到底发送给谁？用什么方式？携带什么参数？要参考项目的API接口文档
# API相关
  ## API分类
    1.REST API(restful风格的api)
        (1)发送请求进行CRUD(增删改查)哪个操作由请求方式决定
        (2)同一个请求路径可以进行多个操作(同意路径即同一个地址)
        (3)请求方式会用到GET/POST/PUT/DELETE
    2.非REST API(restless风格的api)
        (1)请求方式不决定请求的CRUD(增删改查)操作
        (2)一个请求路径只对应个操作
        (3)请求方式一般只有GET/POST
    3.json-server服务器 restful 风格
        用来快速搭建 REST API的工具包
        终端 中输入 json-server xxx.json
            启动服务器 json-server (--watch) xxx.json
    4.psotman 接口测试工具
# Promise
## 1准备
### 1.1 
    实例对象与函数对象
        实例对象:new 构造函数或类产生的对象
        函数对象:将函数作为对象使用时，简称函数对象
        //函数对象
    	function Person (name,age){
    		this.name = name
    		this.age = age
    	}
    	Person.a = 1 //将Person看成一个对象
        const p1 = new Person('老刘',18) //p1是Person的实例对象
### 1.2 同步回调与异步回调
        同步回调:立即执行，完全执行完了才结束，不会放入回调队列中
                例如:数组遍历相关的回调函数/Promise 的excutor函数
    
            //演示同步的回调函数
    	let arr = [1,3,5,7,9]
    	arr.forEach((item)=>{
    		console.log(item);
    	})
    	console.log('主线程的代码'); 
    
        异步回调:不会立即执行，会放入回调队列中将来执行，主线程完成再调(等了多长时间(到某一个时间点)再调用)
                例如:定时器回调/ajax回调/Promise的成功|失败的回调
    	//演示异步的回调函数
    	setTimeout(()=>{
    		console.log('@');
    	},0)//异步回调，定时器执行，时间立刻到了回调函数进入回调队列，console.log输出，回调函数执行
    	console.log('主线程'); 
### 1.3 JS的error处理
        1. 错误的类型
    		Error: 所有错误的父类型
    		ReferenceError: 引用的变量不存在
    		TypeError: 数据类型不正确
    		RangeError: 数据值不在其所允许的范围内--死循环
    		SyntaxError: 语法错误
    
    	2. 错误处理
    		捕获错误: try{}catch(){}
    		抛出错误: throw error
    
    	3. 错误对象
    		message属性: 错误相关信息
    		stack属性: 记录信息
    
        4.如何捕获一个错误
            try中放可能出现错误的代码，一旦出现错误立即停止try中代码的执行，调用catch，并携带错误信息
            try {
    	console.log(1);
    	console.log(a);
    	console.log(2);
            } catch (error) {
    	console.log('代码执行出错了,错误的原因是：',error);
        } 
    
        5.演示
        //演示：ReferenceError: 引用的变量不存在
            console.log(a); *
    
        //演示：TypeError: 数据类型不正确
        const demo = ()=>{}
        demo()() 
    
        //演示：RangeError: 数据值不在其所允许的范围内
        const demo = ()=>{demo()}//递归
        demo() 
    
        //演示：SyntaxError: 语法错误
         console.log(1; 
        6如何抛出一个错误
        function demo(){
    	    const date = Date.now()
    	    if(date % 2 === 0){
    		    console.log('偶数，可以正常工作');
    	    }else{
    		    throw new Error('奇数，不可以工作！')
    	    }
        }
        try {
    	    demo()
        } catch (error) {
    	    debugger;
    	    console.log('@',error);
        }
    
        6.进一步理解JS中的错误(Error)和错误处理
        mdn文档: https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error
## 2.Promise的理解和使用
### 2.1Promise是什么?
		1.抽象表达:
			(1).Promise是一门新的技术(ES6提出的)
			(2).Promise是JS中异步编程的新方案(旧方案是谁?---纯回调)
	
		2.具体表达:
			(1).从语法上来说: Promise是一个内置构造函数
			(2).从功能上来说: Promise的实例对象可以用来封装一个异步操作，并可以获取其成功/失败的值
	
	    1.Promise不是回调，是一个内置的构造函数，是程序员自己new调用的。
		2.new Promise的时候，要传入一个回调函数，它是同步的回调，会立即在主线程上执行，它被称为executor函数
		3.每一个Promise实例都有3种状态：初始化(pending)、成功(fulfilled)、失败(rejected)
		4.每一个Promise实例在刚被new出来的那一刻，状态都是初始化(pending)
		5.executor函数会接收到2个参数，它们都是函数，分别用形参：resolve、reject接收
					1.调用resolve函数会：
							(1).让Promise实例状态变为成功(fulfilled)
							(2).可以指定成功的value。
					2.调用reject函数会：
							(1).让Promise实例状态变为失败(rejected)
							(2).可以指定失败的reason。
	
	    创建一个Promise实例对象
	    const p = new Promise((resolve, reject)=>{
		    reject('ok')
	        })
	    console.log('@',p); //一般不把Promise实例做控制台输出
### 2.2Promise的基本使用
        1. 重要语法
    				new Promise(executor)构造函数
    				Promise.prototype.then方法
    
    	2. 基本编码流程
    				(1).创建Promise的实例对象(pending状态), 传入executor函数
    				(2).在executor中启动异步任务（定时器、ajax请求）
    				(3).根据异步任务的结果，做不同处理：
    							3.1 如果异步任务成功了：
    											我们调用resolve(value), 让Promise实例对象状态变为成功(fulfilled),
                                                同时指定成功的value
    							3.2 如果异步任务失败了：
    											我们调用reject(reason), 让Promise实例对象状态变为失败(rejected),
                                                同时指定失败的reason
    				(4).通过then方法为Promise的实例指定成功、失败的回调函数，来获取成功的value、失败的reason
    							注意：then方法所指定的：成功的回调、失败的回调，都是异步的回调。
    
    	      (5). 模拟一个异步任务
                 const p = new Promise((resolve,reject)=>{
    	         	 setTimeout(()=>{
    	         		resolve('我是成功的数据')
    	         	},2000) 
    	         p.then(
    	         	(value)=>{console.log('成功了1',value);}, //成功的回调-异步
    	         	(reason)=>{console.log('失败了1',reason);} //失败的回调-异步
    	         )
    	         console.log('@')
    	         //P实例创建，setTimeout的回调为异步，进入队列，继续执行p.then,指定成功的回调和失败的回调(此时不确定是否成功)
    	         继续执行console.log输出@，两秒后异步执行，输出成功或失败的回调
          (6).真正开启一个异步任务
             	const xhr = new XMLHttpRequest()
             	xhr.onreadystatechange = ()=>{
             		if(xhr.readyState === 4){
             			//readyState为4代表接收完毕，接收的可能是：服务器返回的成功数据、服务器返回的错误
             			if(xhr.status === 200) resolve(xhr.response)
             			else reject('请求出错')
             		}
             	}
             	xhr.open('GET','https://api.apiopen.top')
             	xhr.responseType = 'json'
    	         	xhr.send()
    	         })
    
    	         p.then(
    	         	(value)=>{console.log('成功了1',value);}, //成功的回调-异步
    	         	(reason)=>{console.log('失败了1',reason);} //失败的回调-异步
    	         )
    	3. 关于状态的注意点：
    				(1).三个状态:
    							pending: 未确定的------初始状态
    							fulfilled: 成功的------调用resolve()后的状态
    							rejected: 失败的-------调用reject()后的状态
    				(2).两种状态改变
    							pending ==> fulfilled
    							pending ==> rejected
    				(3).状态只能改变一次！！
    				(4).一个promise指定多个成功/失败回调函数, 都会调用，不会覆盖
### 2.3封装一个简单的ajax
		定义一个sendAjax函数，对xhr的get请求进行封装：
				1.该函数接收两个参数：url(请求地址)、data(参数对象)
				2.该函数返回一个Promise实例
							(1).若ajax请求成功,则Promise实例成功,成功的value是返回的数据。
							(2).若ajax请求失败,则Promise实例失败,失败的reason是错误提示。
	            function sendAjax(url,data){
	            	return new Promise((resolve,reject)=>{
	            			//实例xhr
	            			const xhr = new XMLHttpRequest()
	            			//绑定监听
	            			xhr.onreadystatechange = ()=>{
	            				if(xhr.readyState === 4){
	            					if(xhr.status >= 200 && xhr.status < 300) resolve(xhr.response);
	            					else reject('请求出了点问题');
	            				}
	            			}
	            			//整理参数
	            			let str = ''
	            			for (let key in data){
	            				str += `${key}=${data[key]}&`
	            			}
	            			str = str.slice(0,-1)
	            			xhr.open('GET',url+'?'+str)
	            			xhr.responseType = 'json'
	            			xhr.send()
	            		})
	            }
	
	            const x = sendAjax('https://api.apiopen.top/getJoke',{page:1,count:2,type:'video'})
	            x.then(
	            	(data)=>{console.log('成功了',data);},
	            	(reason)=>{console.log('失败了',reason);}
	            )
## 3.PromiseAPI
1. Promise构造函数: new Promise (executor) {}
					executor函数: 是同步执行的，(resolve, reject) => {}
					resolve函数: 调用resolve将Promise实例内部状态改为成功(fulfilled)。
					reject函数: 调用reject将Promise实例内部状态改为失败(rejected)。
					说明: excutor函数会在Promise内部立即同步调用,异步代码放在excutor函数中。

2. Promise.prototype.then方法: Promise实例.then(onFulfilled,onRejected)
					onFulfilled: 成功的回调函数 (value) => {}
					onRejected: 失败的回调函数 (reason) => {}
					特别注意(难点)：then方法会返回一个新的Promise实例对象

3. Promise.prototype.catch方法: Promise实例.catch(onRejected)
          onRejected: 失败的回调函数 (reason) => {}
          说明: catch方法是then方法的语法糖, 相当于: then(undefined, onRejected)

4. Promise.resolve方法: Promise.resolve(value)
					说明: 用于快速返回一个状态为fulfilled或rejected的Promise实例对象
					备注：value的值可能是：(1)非Promise值  (2)Promise值 传入的Promise值为失败的实例对象时，此方法创建的也是失败的实例

5. Promise.reject方法: Promise.reject方法(reason)
          说明: 用于快速返回一个状态必为rejected的Promise实例对象 与Promise不一样，不管传入是否为Promise值都为失败实例对像
	
6. Promise.all方法: Promise.all(promiseArr)
          promiseArr: 包含n个Promise实例的数组
          说明: 返回一个新的Promise实例, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败。
                出现一个失败后面的异步回调不再执行
          //例
                   const p1 = Promise.resolve('a')
	        const p2 = new Promise((resolve,reject)=>{
	        	setTimeout(()=>{
	        		reject('b')
	        	},500)
	        })
	        const p3 = new Promise((resolve,reject)=>{
	        	setTimeout(()=>{
	        		reject('c')
	        	},2000)
	        })
	        const x = Promise.all([p1,p2,p3])
	        x.then(
	        	value => {console.log('成功了',value);},
	        	reason => {console.log('失败了',reason);}
	        ) 

7. Promise.race方法: Promise.race(promiseArr)
          promiseArr: 包含n个Promise实例的数组
          说明: 返回一个新的Promise实例, 成功还是很失败？以最先出结果的promise为准。
## 4.promise的几个关键问题
1.	如何改变一个Promise实例的状态?
						(1)执行resolve(value): 如果当前是pending就会变为fulfilled
						(2)执行reject(reason): 如果当前是pending就会变为rejected
						(3)执行器函数(executor)抛出异常: 如果当前是pending就会变为rejected
    状态只能改一次
		    const p  = new Promise((resolve,reject)=>{
		    	console.log(a); //引擎抛异常
		    	// throw 900 //编码抛异常
		    })
		    p.then(
		    	value => {console.log('成功了',value);},
		    	reason => {console.log('失败了',reason);}
		    )
2. 改变Promise实例的状态和指定回调函数谁先谁后?
					1.都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调
					2.如何先改状态再指定回调?
								延迟一会再调用then()
					3.Promise实例什么时候才能得到数据?
								如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据
								如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据
		        //先指定回调，后改变状态（最常见）
		        const p = new Promise((resolve,reject)=>{
		        	setTimeout(()=>{
		        		resolve('a')
		        	},4000)
		        })
		        p.then(
		        	value => {console.log('成功了',value);},
		        	reason => {console.log('失败了',reason);}
		        ) 
	
		        //先改状态，后指定回调
		        const p = new Promise((resolve,reject)=>{
		        	resolve(100)
		        })
		        setTimeout(()=>{
		        	p.then(
		        		value => {console.log('成功了',value);},
		        		reason => {console.log('失败了',reason);}
		        	)
		        },2000)
3. Promise实例.then()返回的是一个【新的Promise实例】，它的值和状态由什么决定?
					1.简单表达: 由then()所指定的回调函数执行的结果决定
					2.详细表达:
							(1)如果then所指定的回调(成功或失败)返回的是非Promise值a:
											那么【新Promise实例】状态为：成功(fulfilled), 成功的value为a
							(2)如果then所指定的回调返回的是一个Promise实例p:
											那么【新Promise实例】的状态、值，都与p一致
							(3)如果then所指定的回调抛出异常:
											那么【新Promise实例】状态为rejected, reason为抛出的那个异常
		            const p = new Promise((resolve,reject)=>{
		            	setTimeout(()=>{
		            		resolve('a')
		            	},1000)
		            })

		            p.then(
		            	value => {console.log('成功了1',value); return Promise.reject('a')},
		            	reason => {console.log('失败了1',reason);}
		            ).then(
		            	value => {console.log('成功了2',value);return true},
		            	reason => {console.log('失败了2',reason); return 100}
		            ).then(
		            	value => {console.log('成功了3',value);throw 900},
		            	reason => {console.log('失败了3',reason); return false}
		            ).then(
		            	value => {console.log('成功了4',value);return -100},
		            	reason => {console.log('失败了4',reason);}
		            )
4. Promise如何串连多个异步任务? -------- 通过then的链式调用
		function sendAjax(url,data){
			return new Promise((resolve,reject)=>{
				//实例xhr
				const xhr = new XMLHttpRequest()
				//绑定监听
				xhr.onreadystatechange = ()=>{
					if(xhr.readyState === 4){
						if(xhr.status >= 200 && xhr.status < 300) resolve(xhr.response);
						else reject('请求出了点问题');
					}
				}
				//整理参数
				let str = ''
				for (let key in data){
					str += `${key}=${data[key]}&`
				}
				str = str.slice(0,-1)
				xhr.open('GET',url+'?'+str)
				xhr.responseType = 'json'
				xhr.send()
			})
		}
		//发送第1次请求
		sendAjax('https://api.apiopen.top/getJoke',{page:1})
		.then(
			value => {
				console.log('第1次请求成功了',value);
				//发送第2次请求
				return sendAjax('https://api.apiopen.top/getJoke',{page:1})
			},
			reason => {console.log('第1次请求失败了',reason);}
		)
		.then(
			value => {
				console.log('第2次请求成功了',value);
				//发送第3次请求
				return sendAjax('https://api.apiopen.top/getJoke',{page:1})
			},
			reason => {console.log('第2次请求失败了',reason);}
		)
		.then(
			value => {console.log('第3次请求成功了',value);},
			reason => {console.log('第3次请求失败了',reason);}
		)
5. 中断promise链：
			(1)当使用promise的then链式调用时, 在中间中断, 不再调用后面的回调函数。
			(2)办法: 在失败的回调函数中返回一个pendding状态的Promise实例。
		function sendAjax(url,data){
			return new Promise((resolve,reject)=>{
				//实例xhr
				const xhr = new XMLHttpRequest()
				//绑定监听
				xhr.onreadystatechange = ()=>{
					if(xhr.readyState === 4){
						if(xhr.status >= 200 && xhr.status < 300) resolve(xhr.response);
						else reject('请求出了点问题');
					}
				}
				//整理参数
				let str = ''
				for (let key in data){
					str += `${key}=${data[key]}&`
				}
				str = str.slice(0,-1)
				xhr.open('GET',url+'?'+str)
				xhr.responseType = 'json'
				xhr.send()
			})
		}
		//发送第1次请求
		sendAjax('https://api.apiopen.top/getJoke',{page:1})
		.then(
			value => {
				console.log('第1次请求成功了',value);
				//发送第2次请求
				return sendAjax('https://api.apiopen.top/getJoke2',{page:1})
			},
			reason => {console.log('第1次请求失败了',reason);return new Promise(()=>{})}
		)
		.then(
			value => {
				console.log('第2次请求成功了',value);
				//发送第3次请求
				return sendAjax('https://api.apiopen.top/getJoke',{page:1})
			},
			reason => {console.log('第2次请求失败了',reason);return new Promise(()=>{})}
		)
		.then(
			value => {console.log('第3次请求成功了',value);},
			reason => {console.log('第3次请求失败了',reason);}
		)
6. promise错误穿透：
			(1)当使用promise的then链式调用时, 可以在最后用catch指定一个失败的回调,
			(2)前面任何操作出了错误, 都会传到最后失败的回调中处理了
			备注：如果不存在then的链式调用，就不需要考虑then的错误穿透。
		//另一个例子演示错误的穿透
		const p = new Promise((resolve,reject)=>{
			setTimeout(()=>{
				reject(-100)
			},1000)
		})
		p.then(
			value => {console.log('成功了1',value);return 'b'},
			reason => {throw reason}//当我们不写失败的回调时，底层帮我们补上的这个失败的回调，当p失败时执行失败回调
            导致.then返回的Promise实例失败，从而依次往下失败直到catch
		)
		.then(
			value => {console.log('成功了2',value);return Promise.reject(-108)},
			reason => {throw reason}//底层帮我们补上的这个失败的回调
		)
		.catch(
			reason => {throw reason}
		)

		function sendAjax(url,data){
			return new Promise((resolve,reject)=>{
				//实例xhr
				const xhr = new XMLHttpRequest()
				//绑定监听
				xhr.onreadystatechange = ()=>{
					if(xhr.readyState === 4){
						if(xhr.status >= 200 && xhr.status < 300) resolve(xhr.response);
						else reject(`请求出了点问题`);
					}
				}
				//整理参数
				let str = ''
				for (let key in data){
					str += `${key}=${data[key]}&`
				}
				str = str.slice(0,-1)
				xhr.open('GET',url+'?'+str)
				xhr.responseType = 'json'
				xhr.send()
			})
		}
		//利用错误的穿透避免多次指定失败的回调
		sendAjax('https://api.apiopen.top/getJoke2',{page:1})
		.then(
			value => {
				console.log('第1次请求成功了',value);
				//发送第2次请求
				return sendAjax('https://api.apiopen.top/getJoke',{page:1})
			},
			// reason => {console.log('第1次请求失败了',reason);return new Promise(()=>{})}
		)
		.then(
			value => {
				console.log('第2次请求成功了',value);
				//发送第3次请求
				return sendAjax('https://api.apiopen.top/getJoke',{page:1},3)
			},
			// reason => {console.log('第2次请求失败了',reason);return new Promise(()=>{})}
		)
		.then(
			value => {console.log('第3次请求成功了',value);},
			// reason => {console.log('第3次请求失败了',reason);return new Promise(()=>{})}
		)
		.catch(
			reason => {console.log(reason);}
		)
7. Promise优势：
		1. 指定回调函数的方式更加灵活: 
		   旧的: 必须在启动异步任务前指定
				    promise: 启动异步任务 => 返回promie对象 => 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)

		2. 支持链式调用, 可以解决回调地狱问题
				    (1)什么是回调地狱：
									回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调函数执行的条件
				    (2)回调地狱的弊病：
									代码不便于阅读、不便于异常的处理
				    (3)一个不是很优秀的解决方案：
									then的链式调用
				    (4)终极解决方案：
									async/await（底层实际上依然使用then的链式调用）
### async和await(异步和异步等待)
1. async修饰的函数
				函数的返回值为promise对象
				Promise实例的结果由async函数执行的返回值决定
2. await表达式
				await右侧的表达式一般为Promise实例对象, 但也可以是其它的值
				(1).如果表达式是Promise实例对象, await后的返回值是promise成功的值(只等成功的值)
				(2).如果表达式是其它值, 直接将此值作为await的返回值	
                (3)	await语句的外侧一定要包裹一个async函数
3. 注意:
				await必须写在async函数中, 但async函数中可以没有await
				如果await的Promise实例对象失败了, 就会抛出异常, 需要通过try...catch来捕获处理

	            const p1 = new Promise((resolve,reject)=>{
	            	setTimeout(()=>{
	            		resolve('a')
	            	},1000)
	            })
	            const p2 = new Promise((resolve,reject)=>{
	            	setTimeout(()=>{
	            		resolve('一些错误')
	            	},2000)
	            })
	            const p3 = new Promise((resolve,reject)=>{
	            	setTimeout(()=>{
	            		resolve('c')
	            	},4000)
	            })


	            /* ;(async()=>{
	            	try {
	            		const result1 = await p1
	            		console.log(result1);
	            		const result2 = await p2
	            		console.log(result2);
	            		const result3 = await p3
	            		console.log(result3);
	            	} catch (error) {
	            		console.log(error);
	            	}
	            })() */
	
	            //测试async
 	            async	function demo(){
	            	const result = await p1
	            	console.log(result);
	            }
	            demo()
4. await应用
	function sendAjax(url,data){
		return new Promise((resolve,reject)=>{
			//实例xhr
			const xhr = new XMLHttpRequest()
			//绑定监听
			xhr.onreadystatechange = ()=>{
				if(xhr.readyState === 4){
					if(xhr.status >= 200 && xhr.status < 300) resolve(xhr.response);
					else reject(`请求出了点问题`);
				}
			}
			//整理参数
			let str = ''
			for (let key in data){
				str += `${key}=${data[key]}&`
			}
			str = str.slice(0,-1)
			xhr.open('GET',url+'?'+str)
			xhr.responseType = 'json'
			xhr.send()
		})
	}
	
	(async()=>{
			try {
				const result1 = await sendAjax('https://api.apiopen.top/getJoke',{page:1})
				console.log('第1次请求成功了',result1);
				const result2 = await sendAjax('https://api.apiopen.top/getJoke',{page:1})
				console.log('第2次请求成功了',result2);
				const result3 = await sendAjax('https://api.apiopen.top/getJoke',{page:1})
				console.log('第3次请求成功了',result3);
			} catch (error) {
				console.log(error);
			}
	})()
5. await原理
		 若我们使用async配合await这种写法：
         1.表面上不出现任何的回调函数
         2.但实际上底层把我们写的代码进行了加工，把回调函数“还原”回来了。
         3.最终运行的代码是依然有回调的，只是程序员没有看见。

            const p = new Promise((resolve,reject)=>{
            		setTimeout(()=>{
            			resolve('a')
            		},4000)
            	})
    
            async	function demo(){
            		//程序员“轻松”的写法
            		const result = await p
            		console.log(result);
            		console.log(100);
            		console.log(200);
    
            		//浏览器翻译后的代码
            		/* p.then(
            			result => {
            				console.log(result);
            				console.log(100);
            				console.log(200);
            			},
            		) */
    
            	}
            	demo()
            	console.log(1);
## 5.宏队列与微队列
宏任务:
        dom操作（页面渲染）
        用户交互（鼠标、键盘）
        网络请求（Ajax等）
        History API操作（history.back、history.go…）
        定时器（setTimeout)
浏览器中的队列有两个
			宏队列:[宏任务1，宏任务2.....]
			微队列:[微任务1，微任务2.....](目前的微任务只有Promise)
			规则：每次要执行宏队列里的一个任务之前，先看微队列里是否有待执行的微任务
						1.如果有，先执行微任务
						2.如果没有，按照宏队列里任务的顺序，依次执行
		  //代码一
      /* setTimeout(()=>{
        console.log('timeout')
      },0)

      Promise.resolve(1).then(
        value => console.log('成功1',value)
      )
      Promise.resolve(2).then(
        value => console.log('成功2',value)
      )
      console.log('主线程') */
      定时器指定的回调属于宏任务，放入宏队列
      Promise指定的回调属于微任务进入微队列
    主线程运行，setTimeout执行，定时器立刻到点，其回调进入宏队列；主线程继续与运行，得到成功状态Promise实例然后指定成功1回调，回调进入微队列，主线程继续，得到成功状态Promise实例然后指定成功2回调进入微队列，在成功1之后。主线程继续执行输出主线程，主线程结束，先执行微任务再在执行宏任务按照进队列的顺序一次执行队列中的回调
    
      //代码二
      /* setTimeout(()=>{
        console.log('timeout1')
      })
      setTimeout(()=>{
        console.log('timeout2')
      })
    
      Promise.resolve(1).then(
        value => console.log('成功1',value)
      )
      Promise.resolve(2).then(
        value => console.log('成功2',value)
      ) */
    
      //代码三
      setTimeout(()=>{
        console.log('timeout1')
        Promise.resolve(5).then(
          value => console.log('成功了5')
        )
      })
      setTimeout(()=>{
        console.log('timeout2')
      })
    
      Promise.resolve(3).then(
        value => console.log('成功了3')
      )
      Promise.resolve(4).then(
        value => console.log('成功了4')
      )
    控制台输出：成功3、成功4、timeout1、成功5、timeout2
# Axios
    ajax是一种特别的http请求，只有XHR和fetch发出的请求是ajax请求
## axios基本使用
        1.axios调用的返回值是Promise实例。
    			2.成功的值叫response，失败的值叫error。
    			3.axios成功的值是一个axios封装的response对象，服务器返回的真正数据在response.data中
    			4.携带query参数时，编写的配置项叫做params
    			5.携带body参数时，编写的配置项叫做data
    			6.携带params参数时，就需要自己手动拼在url中
    
        实例代码
        //给axios配置默认属性
    		  axios.defaults.timeout = 2000
    		  axios.defaults.headers = {school:'atguigu'}
    		  axios.defaults.baseURL = 'http://localhost:5000'/所有用axios发送的请求，请求的基本路径均为：http://localhost:5000
    
        axios({
             url:'/person'
             method:      //请求方式
             data:{name:ys,age:41}       //请求体参数json编码格式
             data:'name=ys&age=41'//请求体参数urlencoded编码格式
             params:{name:ys,age:41}     //query参数
             timeout:2000//配置超时时间  
             headers:{} //配置请求头
             responseType:'json'//配置响应数据的格式(默认值)，当返回的数据不是json而配置该项时会返回null
           }).then(
            //response是经过axios包装后的一个对象，服务器真正返回的数据在：response.data
            response => {console.log('成功了',response.data);},
    				  error => {console.log('失败了',error);}
           )
           简写
           //query参数
           axois.get('url',{params:{name:ys,age:41}}).then(
             response => {console.log('成功了',response.data);},
    				  error => {console.log('失败了',error);}
           )
           //body参数-json编码格式
           axios.post("http://localhost:3000/person", { name: personsName.value, age: personsAge.value }).then(
             response => {console.log('成功了',response.data);},
    				  error => {console.log('失败了',error);}
           )
           //body参数-urlencoded编码格式
           axios.post("http://localhost:3000/person", 'name=personsName.value& age=personsAge.value').then(
             response => {console.log('成功了',response.data);},
    				  error => {console.log('失败了',error);}
           )
## axios.create方法
      axios.create(config)
    			1. 根据指定配置创建一个新的axios, 也就是每个新axios都有自己的配置
    			2. 新axios只是没有【取消请求】和【批量发请求】的方法, 其它所有语法都是一致的
    			3. 为什么要设计这个语法?
    				需求: 项目中有部分接口的配置与其他的不太一样
        4.axios.creat要放在axios之上
        示例代码
        const btn = document.getElementById('btn')
    		const btn2 = document.getElementById('btn2')
    		const btn3 = document.getElementById('btn3')
    
      //creat方法创建axios2并配置默认属
    		const axios2 = axios.create({
    			timeout:3000,
    			//headers:{name:'tom'},
    			baseURL:'https://api.apiopen.top'
    		})
    
    		//给axios配置默认属性
    		axios.defaults.timeout = 2000
    		axios.defaults.headers = {school:'atguigu'}
    		axios.defaults.baseURL = 'http://localhost:5000'
    
    		btn.onclick = ()=>{
    			axios({
    				url:'/persons', //请求地址
    				method:'GET',//请求方式
    			}).then(
    				response => {console.log('成功了',response.data);},
    				error => {console.log('失败了',error);}
    			)
    		}
      //creat方法创建的axios
      btn3.onclick = ()=>{
    			axios2({
    				url:'/getJoke',
    				method:'GET'
    			}).then(
    				response => {console.log('成功了',response.data);},
    				error => {console.log('失败了',error);}
    			)
    		}
## 拦截器
				axios请求拦截器
					1.是什么？
							在真正发请求前执行的一个回调函数
					2.作用：
							对所有的请求做统一的处理：追加请求头、追加参数、界面loading提示等等
				
				axios响应拦截器
					1.是什么？
							得到响应之后执行的一组回调函数
					2.作用：
							若请求成功，对成功的数据进行处理
							若请求失败，对失败进行统一的操作
	      3.后指定的先执行
	    示例代码
	        //请求拦截器
		        axios.interceptors.request.use((config)=>{
	          //config为一次请求的所有配置项
		        	console.log('请求拦截器1执行了');
		        	if(Date.now() % 2 === 0){
		        		config.headers.token = 'atguigu'//token为凭据，凭据正确允许对服务器请求
		        	}
		        	return config
		        })
	
		        //响应拦截器
		        axios.interceptors.response.use(
		        	response => {
		        		console.log('响应拦截器成功的回调执行了',response);
		        		if(Date.now() % 2 === 0) return response.data
		        		else return '时间戳不是偶数，不能给你数据'
		        	},
		        	error => {
		        		console.log('响应拦截器失败的回调执行了');
		        		alert(error);
		        		return new Promise(()=>{})//此处若不写return则返回值为undefinend,为非Promise值，则后面的走成功的回调，若返回一个Promise实例(处于初始化状态)则终止响应
		        	}
		        )
	
		        btn.onclick = async()=>{
		        	const result = await axios.get('http://localhost:5000/persons21')
		        	console.log(result);
		        }
## 取消请求
			const btn = document.getElementById('btn')
			const btn2 = document.getElementById('btn2')
			const {CancelToken,isCancel} = axios //解构赋值(CancelToken=axios.CancelToken) CancelToken是一个构造函数，能为一次请求“打标识”
			let cancel
	
			axios.interceptors.request.use((config)=>{
				if(cancel) cancel('取消了')
				config.cancelToken = new CancelToken((c)=> cancel= c)
	    //c是一个函数，调用c就可以关闭本次请求，此处将c赋值给cancle
				return config
			})
	
			axios.interceptors.response.use(
				response => {return response.data},
				error => {
					if(isCancel(error)){
						//如果进入判断，证明：是用户取消了请求
						console.log('用户取消了请求，原因是：',error.message);
					}else{
						console.log('失败了',error);
					}
					return new Promise(()=>{})
				}
			)
	
			btn.onclick = async()=>{
				const result = await axios.get('http://localhost:5000/test1?delay=3000')
				console.log(result);
			}
	
			btn2.onclick = ()=>{
				cancel('任性，就是不要了')
			}
## 批量发送请求 axios.all

			btn.onclick = async()=>{
				axios.all([
					axios.get('http://localhost:5000/test1'),
					axios.get('http://localhost:5000/test2?delay=3000'),
					axios.get('http://localhost:5000/test3'),
				]).then(
					response => {console.log(response);},
					error => {console.log(error);}
				)
			}
# 模块化
## CommonJS_Node
  暴露的本质是module.exports的引入
 引入的是什么取决于暴露的是什么
    
  1. 定义暴露模块:

    module.exports = value; 此方法暴漏的东西必须放在一起
   exports.xxx = value;可以随意的暴露任意东西exports是一个对象，引入时可以解构赋值
   module.exports和exports不能混用，若混用以module.exports为主
  2. 引入模块:

    var module = require(模块名或模块路径);//第三方模块用模块名，自定义模块用模块路径
## ES6
### 分别暴露
  module采用分别暴露想暴露哪个就在哪个加export
    export const data ='ys'
    export const msg='hello'
    export function showData(){
    console.log(data)
    }

  //引入分别暴露模块
  import {data,msg,showData,showMsg} from './module1'
  //引入分别暴露模块+重命名
  import {data as data2} from './module2'
  //引入分别暴露模块+打包引入
  import *as module1 from './module1'
### 统一暴露
    const school ='chd'
    const person={
        name:'小明',
        age:18
     }
    function showSchool(){
        console.log(school)
    }
    function getPerson(){
        console.log(person)
    }
    //统一暴露
    //精简写法
    export {school,person,getPerson,showSchool}
    //完整写法
    export {school as a,person as b ,getPerson as c,showSchool as d}
    
    //引入统一暴露模块(支持引入分别暴露的三种方法)
    import {data,msg,showData,showMsg} from './module3'
### 默认暴露
  export default js表达式(表达式是指能得到值)
  //默认暴露只暴露————适用于只暴露一个数据
  export default {
     name:'wc',
      age:5
  }

  //引入默认暴露
  import module4 from './module5'
### 多种暴露混用
      //分别暴露
      export const teacher1={name:'tianyu1',age:18}
      export const teacher2={name:'tianyu2',age:18}
      //统一暴露
      const stu1={name:'ys1',age:18}
      const stu2={name:'ys2',age:18}
      export{stu1,stu2}
      //默认暴露
      export default {
          name:'wc',
          age:5
      }
    //引入混用暴露
    import module5,{stu1,stu2,teacher1,teacher2} from './module5'
## ES6-Babel-Browserify模块化教程

### 1. 创建项目结构
  ```
  |-js
    |-src
      |-module1.js
      |-module2.js
      |-module3.js
      |-app.js
  |-index.html
  |-package.json
    {
    "name" : "es6-modular-0318",
    "version" : "1.0.0"
  }
  ```

### 2. 安装babel-cli, babel-preset-es2015和browserify:
第一步，全局安装：```npm install babel-cli browserify -g ```
第二步，局部安装：```npm install babel-preset-es2015 --save-dev``` 
	
### 3. 定义.babelrc文件(给babel指定具体的任务)，内容如下：
```
{
   "presets": ["es2015"]
}
```

### 4. 编码
  * js/src/module1.js
    ```
    //分别暴露
    export function foo() {
      console.log('module1 foo()');
    }
    export function bar() {
      console.log('module1 bar()');
    }
    export const DATA_ARR = [1, 3, 5, 1]
    ```
  * js/src/module2.js  
    ```
    //统一暴露
    let data = 'module2 data'
    
    function fun1() {
      console.log('module2 fun1() ' + data);
    }
    
    function fun2() {
      console.log('module2 fun2() ' + data);
    }
    
    export {fun1, fun2}
    ```
  * js/src/module3.js
    ```
    //默认暴露
    export default {
      name: 'Tom',
      setName: function (name) {
        this.name = name
      }
    }
    ```

  * 下载jQuery模块: ```npm install jquery --save```
  
  * js/src/app.js
    ```
    import {foo, bar} from './module1'
    import {DATA_ARR} from './module1'
    import {fun1, fun2} from './module2'
    import person from './module3'
    
    import $ from 'jquery'
    
    $('body').css('background', 'red')
    
    foo()
    bar()
    console.log(DATA_ARR);
    fun1()
    fun2()
    
    person.setName('JACK')
    console.log(person.name);
    ```

### 5. 编译源代码
  * 第一步：使用Babel将ES6编译为ES5代码，命令为: ```babel js/src -d js/lib```
  * 第二步：使用Browserify编译js上一步生成的js，命令为: ```browserify js/lib/app.js -o js/lib/bundle.js```
  * 备注：第一步操作后Babel将es6的模块化语法，转换成了CommonJS模块化语法（浏览器不识别），所以需要第二步用Browserify再次编译。

### 6. 页面中引入测试
  ```
  <script type="text/javascript" src="js/lib/bundle.js"></script>
  ```

## CommonJS模块化规范
# 跨域即端口号不一样
    协议、域名（ip）、端口都相同才能算是在一个域内
# 解决跨域问题
    JSONP 只支持get请求
    form img link iframe script 等标签 、xhr、地址栏 都是可以发出get请求
    Cors  response.setHeader('Access-Control-Allow-Origin','*') //响应头指定了该响应的资源是否被允许与给定的端口共享第二个指定一个可以访问资源的 URI，"*"表示所有的都可以，用于解决跨域
      response.setHeader('Access-Control-Expose-Headers','*') 
# json-server服务器 restful 风格
    用来快速搭建 REST API的工具包
    终端 中输入 json-server xxx.json
    启动服务器 json-server (--watch) xxx.json
# express服务器
1.引入express 模块
    const express=require('express')
2.创建app服务对象
    constant app=express()

    /*
    //使用中间件解析post请求的urlencoded编码形式的请求体参数
    app.use(express.urlencoded({extended:true}))
    //使用中间件解析post请求的json编码形式的请求体参数
    app.use(express.json())
    */
    //暴露静态资源，src作为服务器根目录  //后端一般用static 或public 前端打包资源放在这里
    app.use(express.static(__dirname+'/src'))

3.设置路由
    //响应get请求——接收query参数
    app.get('/',(request,response)=>{
        console.log('有人发送了get请求了,携带的query',request.query);
         response.setHeader('Access-Control-Allow-Origin','*') //响应头指定了该响应的资源是否被允许与给定的端口共享第二个指定一个可以访问资源的 URI，"*"表示所有的都可以，用于解决跨域
	       response.setHeader('Access-Control-Expose-Headers','*') */
        reponse.send()
    })
    //响应get请求——接收params参数
    app.get('/test_get2/:name/:age',(request,response)=>{
        console.log('有人发送了get请求了,携带的params参数',request.params);
        reponse.send()
    })
    //响应post请求————接收body参数一级路由
    app.post('/test_post',(request,response)=>{
        
        reponse.send()
    })
    //get请求二级路由
    app.get('/test_get/test_two',(request,response)=>{
        
        reponse.send()
    })
4.设置服务器运行窗口
    app.listen(5000,(err)=>{
        if(!err) console.log('服务器启动成功')
        else console.log(err)
    })
# ajax请求
    1创建 XMLHttpRequest实例对象
        const xhr =new XMLHttpRequest()
    2设置请求信息
        xhr.open('method','url')//配置请求
        xhr.setRequestHeader(key,value)//设置请求(可选)
    3.发送请求
        xhr.send(body)//get请求不传递body参数，只有Post请求传递
    4.接收响应
        xhr.onreadystatechange=() => {
                if(xhr.readyStatus===4 && xhr.status===200){
                    console.log(xhr.response)
                }
    
            //responseType用于指定返回数据的类型
            xhr.responseType = 'json'//说明返回数据类型为json,xhr自动解析若返回的不是json格式，则返回null
    
            //配置出错的回调
            xhr.onerror=() => {
                alert('当前网络不稳定')
            }
    
            //超时时间
            xhr.timeout=2000
            xhr.ontimeout= () => {
                alert('网络超时，请重试')
            }
    # xhr.abort()//取消请求
# node.js原生服务器
搭建node原生服务器
    /* request请求对象 response 响应对象 */
1.引入node内置http模块

    let http=require('http')
    
    //引入一个内置模块用于解析key=value&key=value&…………这种形式的字符串为js中的对象
    /*形如：key=value&key=value&………… 的编码形式 ：urlencoded编码形式 
    请求地址里携带的urlencoded编码形式的参数，称为查询字符串参数*/
    //urlencoded是一种编码形式  查询字符串参数是一种参数形式，地址栏中
    //引入的qs是一个对象，该对象有很多方法，代表性方法：parse()
l   et qs=require('querystring')

2.创建一个服务员————创建服务对象

    let serve=http.createServer(function(request,response){
    
    /*让服务员开始干活获取客人点的菜单
    request ：请求对象，里面包含客户端给服务器的东西
    response ：响应对象，里面包含服务器要返回给客户端的东西
    发送一次请求，回调函数调用一次*/
    let params=request.url.split('?')[1]//获取客户端传递过来的urlencoded编码形式的参数 name=zhangsan&age=18
    let paramsObj=qs.parse(params)//将params解析为对象形式 {name:'zhangsan',age:'18'}
    console.log(paramsObj)
    let {name,age}=paramsObj//解构赋值
    //console.log(request.url.split('?')[1]) //发送的请求数据
    
    //响应请求，反馈客户端东西
    response.setHeader('content-type','text/html;charset=utf-8')//设置响应头，说明语言类型
    response.end(`<h1>你好${name},你的年龄是${age}</h1>`) //反单引号,反馈数据、模板字符串
    })
//3.指定服务器运行的端口号（绑定端口监听）常用：3000、4000、5000、8080
    serve.listen(5000,function(err){
    if(!err) console.log('服务器启动成功')
    else console.log('服务器启动失败')
})
# npm
    在文件夹中 npm 先初始化 npm init -y
    npm更新  npm install npm@latest -g        -g全局安装
    npm i -g 包名 全局安装
    npm i 补全依赖包
    安装依赖包  npm i 库名   库名去npm 官网查询
# git
    git init 初始化
    git clone 仓库地址 //克隆仓库到本地
    git add *  //添加当前目录下的所有文件到暂存区
    git commit -m 'xxx' //说明干了什么事
    git push origin master  //推送到github仓
    git pull origin master  //获取最新仓库内容
    git init //初始化本地库
    git remote -v   //查看别名
    git remote add xxx  仓库地址 //创建别名
    git checkout 分支名 //切换到分支
    //1GitHub创建远程库
    //2git bash 创建别名
    //3 git push 别名 分支
# 日常积累
## js
1. 方法放在原型上的是给实例对象用的，放在函数上是给函数自身用的  例如 Promise.prototype.catch方法：Promise实例.catcch
    Promise.resolve方法：Promise.resolve
2. 自执行匿名函数(IIFE)
        写IIFE时前面一般加个分号,不然容易出现语法错误
        第一部分是包围在 圆括号运算符 () 里的一个匿名函数，这个匿名函数拥有独立的词法作用域。这不仅避免了外界访问此 IIFE 中的变量，而且又不会污染全局作用域。
        第二部分再一次使用 () 创建了一个立即执行函数表达式，JavaScript 引擎到此将直接执行函数。
        示例
        ;(function (x) {
        console.log('x + x = ', x + x);
                })(5) // x + x = 10
3. query.stringfy 将对象变为urlencoded编码形式
4. e.currentTarget : 指的是绑定了事件监听的元素（可以理解为触发事件元素的父级元素）
   e.target： 指的是真正触发事件的那个元素

                    event.target经常使用的属性有以下几个：
                                    
                        event.target.nodeName  　　 //获取事件触发元素标签name
                                    
                        event.target.id　　　　　　　//获取事件触发元素id
                                    
                        event.target.className　　  //获取事件触发元素classname
                                    
                        event.target.innerHTML　　  //获取事件触发元素的内容
5. 0, '', null, undefined, NaN，{}, [], Infinity求布尔值，
    分别是false false false false false true true true.
6. praseInt 取整
## HTML
1. 自定义属性
  data-属性名='属性值' 获取属性 dataset.属性名
## 合并对象
    1. Object.assign
    
    let obj1 = {a:1,b:2}
    let obj2 = {c:3}
    
    let obj3 = Object.assign({},a,b)
    // obj3 是深拷贝,obj3是一个新对象
    let obj4 = Object.assign(a,b)
    // 目标对象a也变了
    2. $.extend()
    
    let obj1 = {a:1,b:2}
    let obj2 = {c:3}
    
    let obj3 = $.extend(ture,a,b)
    // obj3 是深拷贝,obj3是一个新对象,ture 表示接受深拷贝
    let obj4 = $.extend(a,b)
    // 目标对象a也变了
    3. 解构赋值
    
    let obj1 = {a:1,b:2}
    let obj2 = {c:3}
    
    let obj3 = {...obj1,...obj2}
     // 解构赋值只进行了一层深拷贝，多层依旧是浅拷贝
    4. 遍历
    
    var obj1={'a':1};
    var obj2={'b':2,'c':3};
    for(var key in obj2){
         if(obj2.hasOwnProperty(key)===true){    <br> 
         //此处hasOwnProperty是判断自有属性，使用 for in 循环遍历对象的属性时，原型链上的所有属性都将被访问会避免原型对象扩展带   来的干扰
               obj1[key]=obj2[key];
    } 
    }
    
    console.log(obj1);//{'a':1,'b':2,'c':3};
## css
   tamplate包裹元素但不生成真实的dom元素
   flxe

# 常用库
  Lodash 遍历字符串，对象和数组 创建复合函数 操作和测试值 防抖与节流
  Moment 处理日期的操作、验证、解析或格式化
  Day.js 一个极简的处理时间和日期的 JavaScript 库，和 Moment.js 的 API 设计保持一样, 但体积仅有2KB。
  qs 一个轻量的 url参数转换的 JavaScript 库 可将对象转为urlencoded编码格式
  vue.resource
  connect-history-api-fallback
  element-ui
    1.npm install babel-plugin-component -D //安装开发版
    2.babelrc 现在是 babel.config.js
        ["es2015", { "modules": false }]修改为["@babel/preset-env", { "modules": false }]
  mock.js  ： 模拟数据
  qrcode  :二维码
  lazyload: 懒加载
  vee-validate 表单验证 版本2.x